---
title: http-session-cookie-token
date: 2020-05-17 15:56:00
tags: http
---

#### http 无状态

###### HTTP无状态协议，是指协议对于交互性场景没有记忆能力。无登录状态，即服务器不知道某个用户是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在/login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）

此时的服务器只处理用户发来的请求，并没有记录用户的登录状态，所以在某些需要登录操作的场景下，显得尤为不足

每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】

**一种常见的对状态的误解：**

1. 有人在解释HTTP的无状态时，把它跟有连接对立，说是两种方式，也就是如果想不无状态，就必须有连接，但其实不然
2. 有连接和无连接以及之后的Keep-Alive都是指TCP连接
3. 有状态和无状态可以指TCP也可以指HTTP
4. TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态

开始TCP是有连接，后来TCP无连接，再后来也就是现在TCP是Keep-Alive，有点像有连接

#### 解决

为了帮助服务器存储客户端状态，我们引入了cookie 和 session

**Cookie**

Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，***浏览器把请求的网址连同该Cookie一同提交给服务器\***。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容

##  Cookie的不可跨域名性

 很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？

答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。

Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie

实例

###### 1.在登录网站的时候选择记住密码，此时服务器会返回给浏览器一个set-cookie字段

###### 2.查看Chrome 浏览器中的cookie设置会发现刚刚服务器返回给我们的cookie

###### 3.观察服务器返回的cookie 发现和浏览器存储的是一致的

###### 4.再次访问这个网站，发现不需要输入密码即可登录，此时观察请求头中的信息里面，浏览器把我们本地存储的cookie字段一并发送给了服务器

## **Cookie 保存登录信息有多种方案**

- 方案一：最直接的是把用户名与密码都保持到Cookie中，下次访问时检查Cookie中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到Cookie中。
- 方案二：是把密码加密后保存到Cookie中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到Cookie与数据库中，到时只验证用户名与登录时间戳就可以了。
- 方案三：只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。实现方式是把账号按照一定的规则加密后，连同账号一块保存到Cookie中。下次访问时只需要判断账号的加密规则是否正确即可。

#### cookie的属性

一般cookie所具有的属性，包括：

Domain：域，表示当前cookie所属于哪个域或子域下面。（上面说了 cookie不可跨域，也就是每个网站只能使用自己网站的cookie,不会发生错乱的情况）

对于服务器返回的Set-Cookie中，如果没有指定Domain的值，那么其Domain的值是默认为当前所提交的http的请求所对应的主域名的。比如访问 http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。

Path：表示cookie的所属路径。

Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。

secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。

httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。

![](E:/Git/newBlog/SheilaTing.github.io/source/img/http/cookie.png)

#### 解决无状态问题的例子

让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： 

  1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 

  2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 

  3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 

  由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 

#### session

**理解session机制** 

<img src="../img/http/session.jpg" style="zoom:200%;" />

参考若愚老师的文章 https://zhuanlan.zhihu.com/p/58490770

**session 的安全策略 以及 session 机制的缺点**

###### 万一sessionId被泄露，那么请求就可以被伪造，例如被 XSS攻击获取这个cookie中的sessionId

**解决如何使session更安全**

###### 1.服务器端设置http-only,这样客户端就不能通过document.cookie来获取cookie，也就避免了xss攻击

###### 2.使用https，加secure字段，secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效

**session的缺点**

###### 1.使用场景限制 cookie 只能在浏览器中使用，换了其他客户端，小程序没有Cookie自然无法使用这个机制

###### 2.这个机制，服务器端需要创建session 对象，如果将session放在内存中，那如果有1000个对象访问那内存中岂不是又1000个对象，如果每个对象中的数据又很多，那内存会不会爆掉。不存在内存中，那么把它存入数据库中，例如redis数据库，那如果我们使用分布式服务器，又要考虑数据库的复用性，服务器端要做更多的事情来处理

#### JWT鉴权机制（解决session机制的弊端）JSON web token

<img src="../img/http/jwt.jpg" style="zoom:200%;" />

第四步.token字符串的规则分为三部分，str1:鉴权机制，算法  str2：用户信息  str3:HMAC(str1+str2，secret_key)

服务器把token发给浏览器，客户端存储下来，下次请求带上token即可，服务器端收到后，验证token,服务器使用 HMA()方法把客户端发来的数据拆开（base64先解密，因为发之前加密了），然后加上自己的 secretkey经过运算得到str3的值如果与发送来的str3一致，认证成功

优点就是session 的缺点，缺点：增加了服务器端计算的压力

还有一个缺点：token是有过期时间的，如果用户刚登录就点击了注销，那么此时token的过期时间还没到，依然是有效的，token的续期问题。。。。。发现越是想要做的安全，服务器还是要存储一些东西，反而变得复杂了，哈哈

#### Auth2 机制 （Open Authorization 开放授权）

###### 是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息

**流程**

<img src="../img/http/auth2.jpg" style="zoom:200%;" />

参考这个：https://www.barretlee.com/blog/2016/01/10/oauth2-introduce/

#### XSS攻击 （跨站脚本攻击）

xss就是攻击者在web页面插入恶意的Script代码，当用户浏览该页之时，嵌入其中web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。例如我们允许客户端上传图片

造成 XSS 有几个要点：

1. 恶意用户可以提交内容

2. 提交的内容可以显示在另一个用户的页面上

3. 这些内容未经**过滤**，直接**运行**在另一个用户的页面上

## 举例说明

假设我们有一个评论系统。

用户 A 提交评论「小谷你好」到服务器，然后用户 B 来访问网站，看到了 A 的评论「小谷你好」，这里没有 XSS。

恶意用户 H 提交评论「<script>console.log(document.cookie)</script>」，然后用户 B 来访问网站，这段脚本在 B 的浏览器直接执行，恶意用户 H 的脚本就可以任意操作 B 的 cookie，而 B 对此毫无察觉。有了 cookie，恶意用户 H 就可以伪造 B 的登录信息，随意访问 B 的隐私了。而 B 始终被蒙在鼓里。

所以我们前后端要做的就是要处理用户的输入，后端模板中不要直接展示用户的输出，可以把尖括号改为html实体符号输出，前端避免直接使用dom.html()来输出内容，尽量使用dom.text();

js 中不要用 eval (这个我还真不知道哎)

#### CSRF攻击

###### CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。

 CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。

　　服务器在返回用户响应的时候生成一个随机数，set到客户端的 cookie中，并且在页面上写一个隐藏的input 值就是这个随机数，那么每次向服务器发送请求时都会带上这个csrf_token服务器通过cookie拿到这个值，以及页面隐藏的这个值，对比如果一致则执行，不一致就拒绝

想一下：如果攻击者去伪造这个随机数，服务器发现与页面传来的不一致不会执行。

　　