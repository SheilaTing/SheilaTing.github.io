---
title: http-TCP
date: 2020-05-14 12:47:30
tags:
---

#### osi

###### 开放式系统互联通信参考模型（open system intercnnection reference model）;

##### 应用层 （Application Layer）

###### 提供为应用软件而设的接口，以设置与另一应用软件之间的通信。例如：http,https,ftp,telnet,ssh,smtp,pop3等

##### 表示层 (Presentation Layer)

###### 把数据转换为能与接收者的系统格式兼容并适合传输的格式

##### 会话层 （Session Layer）

###### 负责在数据传输中设置和维护计算机网络中两台计算机之间的通信连接

##### 传输层 （Transport Layer）

###### 把传输表头（th）加至数据以形成数据包。传输表头包含了所使用的协议等发送信息。例如TCP、UDP等。

##### 网络层 （Network Layer）

###### 数据链路层（Data Link Layer） 负责网络寻址，错误侦测和改错。当表头和表尾被加至数据包时，会形成帧。数据链表头（DLH）是包含了物理地址和错误帧测以及改错的方法。数据链表尾（DLT）是一串指示数据包末端的字符串。例如：以太网，无线局域网（wifi）和通用分组无线服务GPRS 等；

##### 物理层 （Physical Layer）

###### 在局部局域网上传送数据帧 （data frame）,它负责管理计算机通信设备和网络媒体之间的互通。包括了针脚、电压、线缆规范、集线器、中继器、网卡、主机适配器等；

#### TCP/IP四层模型

##### 应用层

应用层是大多数普通与网络相关的程序为了通过网络与其他程序通信所使用的层。这个层的处理过程是应用特有的；数据从网络相关的程序以这种应用内部使用的格式进行传送，然后被编码成标准协议的格式。每一个应用层协议一般都会使用到传输层协议TCP和UDP协议之一：

运行在TCP协议上的协议：

1. HTTP（80端口），主要用于普通浏览。
2. HTTPS（443端口）,HTTP协议的安全版本。
3. FTP（20和21端口），由名知义，用于文件传输。
4. POP3（110端口），收邮件用。
5. SMTP（25端口），用来发送电子邮件。
6. SSH（22端口），用于加密安全登陆用。

运行在UDP协议上的协议：

1. DHCP（67端口，动态主机配置协议），动态配置IP地址。

其他：

1. DNS（Domain Name Service，域名服务），用于完成地址查找，邮件转发等工作（运行在TCP和UDP协议上）。
2. SNMP（Simple Network Management Protocol，简单网络管理协议），用于网络信息的收集和网络管理。
3. ARP（Address Resolution Protocol，地址解析协议），用于动态解析以太网硬件的地址。

##### 传输层

解决诸如端到端可靠性（数据是否已经到达目的地？）和保证数据按照正确的顺序到达这样的问题。TCP、UDP都是传输层协议。

##### 网络层

解决在一个单一网络上传输数据包的问题。IP协议是网络层协议。

##### 数据链路层

它是数据包从一个设备的网络层传输到另外一个设备的网络层的方法。这个过程能够在网卡的软件驱动程序中控制或者专用芯片中控制。这将完成如添加报头准备发送、通过实体介质实际发送这样一些数据链路功能。另一端，链路层将完成数据帧接收、去除报头并且将接收到的包传到网络层。

<!--more-->

## 关于TCP协议

TCP（Transmission Control Protocol， 传输控制协议）是一种面向连接的、**可靠的**、基于字节流的**传输层**通信协议。与之对应的是UDP（User Datagram Protocol ，用户数据报协议），是**不可靠**的**传输层**协议。

## 三步握手

1. 客户端发送 SYN报文给服务器端，序列号是n，进入 SYN_SEND 状态。
2. 服务器端收到 SYN 报文，回应一个ACK（序列号是n+1）同时发一个 SYN （序列号是m），进入 SYN_RECV 状态。
3. 客户端收到服务器端的 SYN 报文，回应一个 ACK(序列号是m+1）报文，进入 Established 状态

![](../img/http/tcp-request.png)

首先由Client发出请求连接即 SYN=1 ACK=0  (请看头字段的介绍), TCP规定SYN=1时不能携带数据，但要消耗一个序号,因此声明自己的序号是 seq=x

然后 Server 进行回复确认，即 SYN=1 ACK=1 seq=y, ack=x+1,

再然后 Client 再进行一次确认，但不用SYN 了，这时即为 ACK=1, seq=x+1, ack=y+1.

然后连接建立，为什么要进行三次握手呢（两次确认）
————————————————
![](../img/http/request01.png)

## 四步挥手

1. 客户端发送一个 FIN ，告诉服务器想关闭连接。
2. 服务器收到这个 FIN ，发回一个 ACK。
3. 服务器通知应用程序关闭网络连接，应用程序关闭后通知服务器。服务器发送一个 FIN 给客户端 。
4. 客户端发回 ACK 报文确认

## 为什么挥手要四步

这是因为服务端的 LISTEN 状态下的 SOCKET 当收到客户端建立连接请求的SYN 报文后，它可以把 ACK 和 SYN （ ACK 起应答作用，而 SYN 起同步作用）放在一个报文里来发送。但关闭连接时，当服务器收到客户端的 FIN 报文通知时，服务器只能发一个回应报文ACK：“哦，我知道了”，然后通知应用程序。应用程序完成全部数据发送并确定可以终止了，服务器才能发送FIN告诉客户端可以真正断开连接了。所以这一步ACK报文和FIN报文需要分开发送，因此多了一个步骤。

## TCP报文格式

![](../img/http/report.png)

- ACK ： TCP协议规定，只有ACK=1时有效，也规定连接建立后所有发送的报文的ACK必须为1。
- SYN(SYNchronization) ： 在连接建立时用来同步序号。当SYN=1而ACK=0时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使SYN=1和ACK=1. 因此, SYN置1就表示这是一个连接请求或连接接受报文。
- FIN （finis）即完，终结的意思， 用来释放一个连接。当 FIN = 1 时，表明此报文段的发送方的数据已经发送完毕，并要求释放连接。

当客户A 没有东西要发送时就要释放 A 这边的连接，A会发送一个报文（没有数据），其中 FIN 设置为1,  服务器B收到后会给应用程序一个信，这时A那边的连接已经关闭，即A不再发送信息（但仍可接收信息）。  A收到B的确认后进入等待状态，等待B请求释放连接， B数据发送完成后就向A请求连接释放，也是用FIN=1 表示， 并且用 ack = u+1(如图）， A收到后回复一个确认信息，并进入 TIME_WAIT 状态， 等待 2MSL 时间。

为什么要等待呢？

为了这种情况： B向A发送 FIN = 1 的释放连接请求，但这个报文丢失了， A没有接到不会发送确认信息， B 超时会重传，这时A在 WAIT_TIME 还能够接收到这个请求，这时再回复一个确认就行了。（A收到 FIN = 1 的请求后 WAIT_TIME会重新记时）

————————————————
另外服务器B存在一个保活状态，即如果A突然故障死机了，那B那边的连接资源什么时候能释放呢？ 就是保活时间到了后，B会发送探测信息， 以决定是否释放连接

**【注意】中断连接端可以是Client端，也可以是Server端。**

假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，"告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，"告诉Client端，好了，我这边数据发完了，准备好关闭连接了"。Client端收到FIN报文后，"就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，"就知道可以断开连接了"。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
————————————————
版权声明：本文为CSDN博主「Bonnie-帮你」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/daocaoren1543169565/article/details/80535949

