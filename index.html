<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>SheilaTing 的博客呀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SheilaTing 的博客呀">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SheilaTing 的博客呀">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SheilaTing 的博客呀">
  
    <link rel="alternate" href="/atom.xml" title="SheilaTing 的博客呀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SheilaTing 的博客呀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-vue-account" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/24/vue-account/" class="article-date">
  <time datetime="2020-06-24T07:59:17.000Z" itemprop="datePublished">2020-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/24/vue-account/">vue-account</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="搭建vue项目环境"><a href="#搭建vue项目环境" class="headerlink" title="搭建vue项目环境"></a>搭建vue项目环境</h4><h6 id="使用-vue-cli-创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装-vue-cli-yarn-global-add-vue-cli-版本号，然后创建项目："><a href="#使用-vue-cli-创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装-vue-cli-yarn-global-add-vue-cli-版本号，然后创建项目：" class="headerlink" title="使用 @vue-cli 创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装 vue-cli yarn global add @vue-cli@版本号，然后创建项目："></a>使用 @vue-cli 创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装 vue-cli yarn global add @vue-cli@版本号，然后创建项目：</h6><h6 id="vue-create-项目名称-然后进入项目目录-安装-serve-（相当于-react-中的dev-server-可以本地启动一个服务器展示我们的运行效果）安装命令-yarn-add-serve-启动项目-yarn-serve"><a href="#vue-create-项目名称-然后进入项目目录-安装-serve-（相当于-react-中的dev-server-可以本地启动一个服务器展示我们的运行效果）安装命令-yarn-add-serve-启动项目-yarn-serve" class="headerlink" title="vue create 项目名称 然后进入项目目录 安装 serve （相当于 react 中的dev-server,可以本地启动一个服务器展示我们的运行效果）安装命令 yarn add serve, 启动项目 yarn serve"></a>vue create 项目名称 然后进入项目目录 安装 serve （相当于 react 中的dev-server,可以本地启动一个服务器展示我们的运行效果）安装命令 yarn add serve, 启动项目 yarn serve</h6><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><h6 id="写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用"><a href="#写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用" class="headerlink" title="写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用"></a>写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用</h6><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><h6 id="使用插件生成基本的vue组件的代码结构，vscode-编辑器插件名：vscode-snippets-Vetur"><a href="#使用插件生成基本的vue组件的代码结构，vscode-编辑器插件名：vscode-snippets-Vetur" class="headerlink" title="使用插件生成基本的vue组件的代码结构，vscode 编辑器插件名：vscode snippets,  Vetur"></a>使用插件生成基本的vue组件的代码结构，vscode 编辑器插件名：vscode snippets,  Vetur</h6><h6 id="webstorem-插件名：-vue-snippets"><a href="#webstorem-插件名：-vue-snippets" class="headerlink" title="webstorem 插件名： vue snippets"></a>webstorem 插件名： vue snippets</h6><h6 id="snippets-插件的作用就是快速创建不同类型文件的基本代码结构，例如，在-vue-文件中，使用vbase-命令会生成相应的-template-script-和-style-标签"><a href="#snippets-插件的作用就是快速创建不同类型文件的基本代码结构，例如，在-vue-文件中，使用vbase-命令会生成相应的-template-script-和-style-标签" class="headerlink" title="snippets 插件的作用就是快速创建不同类型文件的基本代码结构，例如，在.vue 文件中，使用vbase 命令会生成相应的 template script 和 style 标签"></a>snippets 插件的作用就是快速创建不同类型文件的基本代码结构，例如，在.vue 文件中，使用vbase 命令会生成相应的 template script 和 style 标签</h6><p><strong>我还是觉得能手写就手写吧，可能是之前写过的缘故，现在觉得好熟悉呀！</strong></p>
<h4 id="Vue-中的-以及-scss-中的-这个也好熟悉呀，之前项目有用过的"><a href="#Vue-中的-以及-scss-中的-这个也好熟悉呀，之前项目有用过的" class="headerlink" title="Vue 中的 @ 以及 scss 中的 ~  这个也好熟悉呀，之前项目有用过的"></a>Vue 中的 @ 以及 scss 中的 ~  这个也好熟悉呀，之前项目有用过的</h4><h6 id="vue-中-vue-js-文件的引用都可以使用-as-src-is-an-alias-to-src-而在scss-文件中呢想要使用-当做-src-需要在前面添加-例如："><a href="#vue-中-vue-js-文件的引用都可以使用-as-src-is-an-alias-to-src-而在scss-文件中呢想要使用-当做-src-需要在前面添加-例如：" class="headerlink" title="vue 中 .vue .js 文件的引用都可以使用 @ as src  @ is an alias to /src,而在scss 文件中呢想要使用 @ 当做 src 需要在前面添加 ~ 例如："></a>vue 中 .vue .js 文件的引用都可以使用 @ as src  @ is an alias to /src,而在scss 文件中呢想要使用 @ 当做 src 需要在前面添加 ~ 例如：</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'~@/assets/index.scss'</span>  // 引入 src 下的 assets/index.scss</span><br></pre></td></tr></table></figure>
<h6 id="发现好多-vue-项目都使用-scss"><a href="#发现好多-vue-项目都使用-scss" class="headerlink" title="发现好多 vue 项目都使用 scss"></a>发现好多 vue 项目都使用 scss</h6><h6 id="对了，webstorm-中使用-可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下-webpack-目录为当前项目的node-modules-vue-cli-service-webpack-config-js"><a href="#对了，webstorm-中使用-可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下-webpack-目录为当前项目的node-modules-vue-cli-service-webpack-config-js" class="headerlink" title="对了，webstorm 中使用 ~@ 可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下 webpack 目录为当前项目的node_modules/@vue\cli-service\webpack.config.js"></a>对了，webstorm 中使用 ~@ 可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下 webpack 目录为当前项目的node_modules/@vue\cli-service\webpack.config.js</h6><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4>
        
          <p class="article-more-link">
            <a href="/2020/06/24/vue-account/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/24/vue-account/" data-id="ckcbnl63x001q7ow1yapuwiy1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue项目/">vue项目</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-打包发布问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/react-打包发布问题记录/" class="article-date">
  <time datetime="2020-06-21T08:44:09.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/react-打包发布问题记录/">react 打包发布问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h6 id="今天把这几天学习的项目写完了，然后准备打包，发布到-Github-Pages-上，结果打包后发现各种报错，总的来说就是-打包后的-css-和-js-文件引入错误，路径不对，报错如下："><a href="#今天把这几天学习的项目写完了，然后准备打包，发布到-Github-Pages-上，结果打包后发现各种报错，总的来说就是-打包后的-css-和-js-文件引入错误，路径不对，报错如下：" class="headerlink" title="今天把这几天学习的项目写完了，然后准备打包，发布到 Github Pages 上，结果打包后发现各种报错，总的来说就是 打包后的 css 和 js 文件引入错误，路径不对，报错如下："></a>今天把这几天学习的项目写完了，然后准备打包，发布到 Github Pages 上，结果打包后发现各种报错，总的来说就是 打包后的 css 和 js 文件引入错误，路径不对，报错如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to apply style <span class="keyword">from</span> <span class="string">'http://localhost:3000/assets/styles/custom-style.css'</span> because its MIME type (<span class="string">'text/html'</span>) is not a supported stylesheet MIME type, and strict MIME checking is enabled.</span><br></pre></td></tr></table></figure>
<h6 id="百度了一下，有人说是要在-packge-json-中指定-homepage-为-因为打开控制台发现-index-html引入的资源文件是从-下开始找的，应该在-下开始查找"><a href="#百度了一下，有人说是要在-packge-json-中指定-homepage-为-因为打开控制台发现-index-html引入的资源文件是从-下开始找的，应该在-下开始查找" class="headerlink" title="百度了一下，有人说是要在 packge.json 中指定 homepage 为 .,因为打开控制台发现 index.html引入的资源文件是从 / 下开始找的，应该在 ./ 下开始查找"></a>百度了一下，有人说是要在 packge.json 中指定 homepage 为 .,因为打开控制台发现 index.html引入的资源文件是从 / 下开始找的，应该在 ./ 下开始查找</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"homepage"</span>:<span class="string">"."</span></span><br></pre></td></tr></table></figure>
<h6 id="百度看到一个对build命令后输出的提示的一个解释："><a href="#百度看到一个对build命令后输出的提示的一个解释：" class="headerlink" title="百度看到一个对build命令后输出的提示的一个解释："></a>百度看到一个对build命令后输出的提示的一个解释：</h6><p>你必须把build里的文件直接放到应用服务器的根路径下，比如，你的服务器IP是172.16.38.253，应用服务器端口为8080，你应该保证<a href="http://172.16.38.253:8080这种访问方式，访问到的是你的build下的文件。如果你希望以http://172.16.38.253:8080/build/index.htm这种方式访问应用，那么你可以在package.json文件中增加一个homepage字段，如下：" target="_blank" rel="noopener">http://172.16.38.253:8080这种访问方式，访问到的是你的build下的文件。如果你希望以http://172.16.38.253:8080/build/index.htm这种方式访问应用，那么你可以在package.json文件中增加一个homepage字段，如下：</a></p>
<p>“homepage”: “.”,</p>
<h6 id="不管怎样，这样添加后发现-index-html-中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲："><a href="#不管怎样，这样添加后发现-index-html-中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲：" class="headerlink" title="不管怎样，这样添加后发现 index.html 中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲："></a>不管怎样，这样添加后发现 index.html 中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲：</h6><h6 id="BrowserRouter会变成类似这样的路径-http-111-230-139-105-3001-detail-9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据"><a href="#BrowserRouter会变成类似这样的路径-http-111-230-139-105-3001-detail-9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据" class="headerlink" title="BrowserRouter会变成类似这样的路径  http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据"></a>BrowserRouter会变成类似这样的路径  <a href="http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据" target="_blank" rel="noopener">http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据</a></h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This request URL /detail/9459469 was not found on this server.</span><br></pre></td></tr></table></figure>
<p><strong>所以这个时候必须使用 HashRouter,这时候访问具体页面时就是<a href="http://111.230.139.105:3001/#/detail/9459469" target="_blank" rel="noopener">http://111.230.139.105:3001/#/detail/9459469</a>  改为 HashRouter 后发现问题解决了</strong></p>
<p>另外,webpack打包时要添加NODE_ENV,并且将devtool:’eval-source-map’,去除，不然build出来的js特别大，source map是为了代码出错后采用source-map的形式直接显示你出错代码的位置</p>
<p>打包生产包时去除，加上这两个后大部分简单单页面应用会在100k到200k</p>
<h4 id="HashRouter-和-BrowserRouter-区别"><a href="#HashRouter-和-BrowserRouter-区别" class="headerlink" title="HashRouter 和 BrowserRouter 区别"></a>HashRouter 和 BrowserRouter 区别</h4><p>一、从原理上</p>
<p>HashRouter在路径中包含了#，相当于HTML的锚点定位。（<code>#</code> 符号的英文叫hash，所以叫HashRouter，和散列没关系哦））</p>
<p>而BrowserRouter使用的是HTML5的新特性History，没有HashRouter(锚点定位)那样通用，低版本浏览器可能不支持。</p>
<p>二、从用法上</p>
<p>BrowserRouter进行组件跳转时可以传递任意参数实现组件间的通信，而HashRouter不能(除非手动拼接URL字符串)，因此一般配合Redux使用，实现组件间的数据通信。</p>
<p>三、生产实践</p>
<p>1.HashRouter</p>
<p> HashRouter相当于锚点定位，因此不论#后面的路径怎么变化，请求的都相当于是#之前的那个页面。可以很容易的进行前后端不分离的部署(也就是把前端打包后的文件放到服务器端的public或static里)，</p>
<p>因为请求的链接都是ip地址:端口/#/xxxx，因此请求的资源路径永远为/，相当于index.html，而其他的后端API接口都可以正常请求，不会和/冲突，由于前后端不分离也不会产生跨域问题。</p>
<p>缺点就是丑，路径里总有个#，宝宝表示强迫症犯了…</p>
<p>2.BrowserRouter</p>
<p>因为BrowserRouter模式下请求的链接都是ip地址:端口/xxxx/xxxx，因此相当于每个URL都会访问一个不同的后端地址，如果后端没有覆盖到路由就会产生404错误。</p>
<p>可以通过加入中间件解决，放在服务器端路由匹配的最后，如果前面的API接口都不匹配，则返回index.html页面。但这样也有一些小问题，因为要求前端路由和后端路由的URL不能重复。</p>
<p>比如商品列表组件叫/product/list，而请求商品列表的API也是/product/list，那么就会访问不到页面，而是被API接口匹配到。</p>
<p>解决方法:</p>
<p>进行前后端分离的部署，比如前端地址ip1:端口1，后端接口地址ip2:端口2，使用Nginx反向代理服务器进行请求分发。前端向后端发起请求的URL为nginx所在的服务器+/api/xxx，通过NGINX的配置文件判断，如果URL以api开头则转发至后端接口，否则转发至前端的地址，访问项目只需访问Nginx服务器即可。</p>
<p>参考：<a href="https://www.cnblogs.com/flamestudio/p/11965991.html" target="_blank" rel="noopener">https://www.cnblogs.com/flamestudio/p/11965991.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/21/react-打包发布问题记录/" data-id="ckcbnl640001u7ow1gyuxvf8o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/打包/">打包</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js-装饰器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/js-装饰器/" class="article-date">
  <time datetime="2020-06-13T05:18:15.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/js-装饰器/">js 装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><code>Decorator</code> 是 ES7 的一个新语法正如其“装饰器”的叫法所表达的，他通过添加<code>@方法名</code>可以对一些对象进行装饰包装然后返回一个被包装过的对象，可以装饰的对象包括：类，属性，方法等。</strong> 在使用它之前需要引入babel模块 <code>transform-decorators-legacy</code> 编译成 ES5 或 ES6</p>
<h3 id="1-类的装饰"><a href="#1-类的装饰" class="headerlink" title="1. 类的装饰"></a>1. 类的装饰</h3><p>当装饰的对象是类时，我们操作的就是这个类本身，即装饰器函数的第一个参数，就是所要装饰的目标类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>
<h3 id="2-属性或方法的装饰"><a href="#2-属性或方法的装饰" class="headerlink" title="2. 属性或方法的装饰"></a>2. 属性或方法的装饰</h3><p><strong>对于类属性或方法的装饰本质是操作其描述符，可以把此时的装饰器理解成是 <code>Object.defineProperty(obj, prop, descriptor)</code>的语法糖。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  @readonly(<span class="literal">false</span>)</span><br><span class="line">  method() &#123; <span class="built_in">console</span>.log(<span class="string">'cat'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, key, descriptor</span>) </span>&#123; </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 此处 target 为 C.prototype; </span></span><br><span class="line"><span class="comment">	* key 为 method;</span></span><br><span class="line"><span class="comment">    * 原 descriptor 为：&#123; value: f, enumarable: false, writable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    descriptor.writable = value</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line">c.method = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'dog'</span>)</span><br><span class="line"></span><br><span class="line">c.method() <span class="comment">// cat</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = descriptor.initializer &amp;&amp; descriptor.initializer.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"-----"</span> + oldValue); </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"读取值..."</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue + <span class="string">"!"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"现在在设置值..."</span>);</span><br><span class="line">      oldValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  @observable</span><br><span class="line">  title = <span class="string">"饥⼈⾕"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="built_in">console</span>.log(app.title);</span><br><span class="line">app.title = <span class="string">"jirengu.com"</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/js-装饰器/" data-id="ckcbnl5zm000o7ow1oi5nho68" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-嘚啵嘚两句-class-和-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/嘚啵嘚两句-class-和-function/" class="article-date">
  <time datetime="2020-06-13T05:10:42.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/嘚啵嘚两句-class-和-function/">嘚啵嘚两句 class 和 function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><h6 id="学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"><a href="#学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。" class="headerlink" title="学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"></a>学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。</h6><h6 id="js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用"><a href="#js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用" class="headerlink" title="js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用"></a>js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用</h6><p>今天又犯迷瞪了，还是基本功不扎实</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/嘚啵嘚两句-class-和-function/" data-id="ckcbnl631001d7ow18163ylj2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基本功/">js基本功</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mobx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/mobx/" class="article-date">
  <time datetime="2020-06-13T04:05:32.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/mobx/">mobx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h4><h6 id="之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理"><a href="#之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理" class="headerlink" title="之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理"></a>之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理</h6><h6 id="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"><a href="#上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。" class="headerlink" title="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"></a>上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。</h6><h6 id="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux"><a href="#假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux" class="headerlink" title="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux."></a>假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux.</h6><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p><strong>state</strong></p>
<h6 id="state-中保存了我们要维护的一些数据，也就是一个数据容器"><a href="#state-中保存了我们要维护的一些数据，也就是一个数据容器" class="headerlink" title="state 中保存了我们要维护的一些数据，也就是一个数据容器"></a>state 中保存了我们要维护的一些数据，也就是一个数据容器</h6><p><strong>Action</strong></p>
<h6 id="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"><a href="#如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）" class="headerlink" title="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"></a>如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）</h6><p><strong>computed value</strong> 计算属性值</p>
<h6 id="当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。"><a href="#当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。" class="headerlink" title="当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。"></a>当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。</h6><p><strong>Reaction</strong>s  反应</p>
<h6 id="当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions"><a href="#当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions" class="headerlink" title="当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions"></a>当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions</h6><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable,computed,action,autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="comment">// todos 就是要监控的数据 通过 observale 函数来生成，相当于state中的数据</span></span><br><span class="line"><span class="keyword">const</span> todos = (observable([</span><br><span class="line">    &#123;</span><br><span class="line">        title:<span class="string">'起床'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'穿衣'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'洗漱'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Computed values 这个值是通过 state 中数据得来的，当state 数据更新时，它也会更新</span></span><br><span class="line"><span class="comment">// 通过 computed()函数，操作 state 中的数据</span></span><br><span class="line"><span class="keyword">let</span> uncompletedCount = computed(<span class="function"><span class="params">()</span>=&gt;</span> todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span> !todo.completed.length);</span><br><span class="line"><span class="comment">//Reactions  当state 和 computedValue 改变时会触发 reactions</span></span><br><span class="line">  autorun = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`剩余任务：<span class="subst">$&#123;uncompletedCount&#125;</span>`</span></span><br><span class="line">        todos</span><br><span class="line">         .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line">         .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line">         .join(<span class="string">", "</span>)</span><br><span class="line">    ),</span><br><span class="line">&#125;)       </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">``</span>,.....)  <span class="comment">// console.log 可以这样写的</span></span><br><span class="line"><span class="comment">//这个方法就是 当state 和 computedvalue 变化时，会自动运行这个 autrun 函数，打印出state 中未完成的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actions  用来改变被观察者 也就是 state 中的数据</span></span><br><span class="line"><span class="keyword">const</span> doTask = action(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    todos.find(<span class="function"><span class="params">todo</span>=&gt;</span>!todo.completed).completed = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arry.find(item=&gt;) 函数 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。  一次只返回一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doTask 这个函数，因为action 本身是个函数赋值给 doTask 所以它也是个函数,只不过在action 参数中的函数中做了一些处理，来修改 state 也就是 todos 中的数据。</span></span><br></pre></td></tr></table></figure>
<h4 id="mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记"><a href="#mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记" class="headerlink" title="mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)"></a>mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun, computed, action &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line"> @observable todos = []</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(</span><br><span class="line"> <span class="string">`剩余任务:<span class="subst">$&#123;<span class="keyword">this</span>.uncompletedCount&#125;</span>`</span>,</span><br><span class="line"> <span class="keyword">this</span>.todos</span><br><span class="line"> .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line"> .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line"> .join(<span class="string">", "</span>)</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @computed get uncompletedCount() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).length;</span><br><span class="line"> &#125;</span><br><span class="line">@action addTodo(title) &#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line"> title: title,</span><br><span class="line"> completed: <span class="literal">false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @action doTask()&#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).completed = <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todo = <span class="built_in">window</span>.todo = <span class="keyword">new</span> Todo();</span><br><span class="line">todo.addTodo(<span class="string">'吃饭'</span>);</span><br><span class="line">todo.doTask()</span><br></pre></td></tr></table></figure>
<p><strong>核心思想：状态的改变引发⼀系列⾃动⾏为</strong></p>
<h4 id="react-项目中使用装饰器"><a href="#react-项目中使用装饰器" class="headerlink" title="react 项目中使用装饰器"></a>react 项目中使用装饰器</h4><p>操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create-react-app</span><br><span class="line"></span><br><span class="line">yarn eject 或者 npm run eject 暴露出配置文件</span><br><span class="line"></span><br><span class="line">yarn add @babel/plugin-proposal-decorators  //安装支持 装饰器的插件</span><br><span class="line">修改package.json， 找到 babel字段， 添加</span><br><span class="line">//查看 npm 上 plugin-proposal-decorators 包的用法</span><br><span class="line"> <span class="string">"babel"</span>: &#123;</span><br><span class="line"> <span class="string">"plugins"</span>: [</span><br><span class="line"> <span class="string">"@babel/plugin-proposal-decorators"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"presets"</span>: [</span><br><span class="line"> <span class="string">"react-app"</span></span><br><span class="line"> ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="react-mobx"><a href="#react-mobx" class="headerlink" title="react-mobx"></a>react-mobx</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/mobx/" data-id="ckcbnl5zq000s7ow1kwb7v626" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobx/">mobx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-router/" class="article-date">
  <time datetime="2020-06-12T06:53:47.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-router/">react-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>npm install –save react-router-dom</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h6 id="在页面上引入所需的组件对象"><a href="#在页面上引入所需的组件对象" class="headerlink" title="在页面上引入所需的组件对象"></a>在页面上引入所需的组件对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter || HashRouter <span class="keyword">as</span> Router,</span><br><span class="line">       Switch,</span><br><span class="line">        Route,</span><br><span class="line">        Link</span><br><span class="line">       &#125;  <span class="comment">// 取别名</span></span><br><span class="line"><span class="comment">// hashRouter 和 BrowserRouter 区别是url 一个带 # 一个不带</span></span><br><span class="line"></span><br><span class="line">BrowserRouter 的作用就是声明这个组件被 router 接管了。</span><br><span class="line"><span class="comment">// 在组件 return 的 逻辑中，我们使用 &lt;Router&gt; 标签来包裹这些 路由标签，Switch,route,link 等</span></span><br><span class="line">Switch 相当于 js 中的 <span class="keyword">switch</span> 语句主要用来判断不同的条件执行不同的代码</span><br><span class="line">Route 标签则是用来渲染组件的，一般会包裹一个组件，或者在它的属性上使用 component，children 来指定要渲染的组件   </span><br><span class="line">Link 标签则是指定点击时要跳转的组件路径 很像 a 链接</span><br></pre></td></tr></table></figure>
<p><strong>下面是一个简单的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">    Switch,</span><br><span class="line">    Route,</span><br><span class="line">    Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Nav</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Link to="/</span>history<span class="string">"&gt;历史&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/my<span class="string">"&gt;我的&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/about<span class="string">"&gt;关于&lt;/Link&gt;</span></span><br><span class="line"><span class="string">            &lt;/nav&gt;</span></span><br><span class="line"><span class="string">            &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/about<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;About/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/history<span class="string">" component=&#123;History&#125;&gt;              </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/my<span class="string">" children=&#123;&lt;My/&gt;&#125;&gt;</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/home<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;Home/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/Router&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Home()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;首页&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function History()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;历史&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function My()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;我的&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function About()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;关于&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Nav;</span></span><br></pre></td></tr></table></figure>
<h6 id="当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。"><a href="#当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。" class="headerlink" title="当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。"></a>当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。</h6><h4 id="Navlink-amp-Redirect"><a href="#Navlink-amp-Redirect" class="headerlink" title="Navlink &amp; Redirect"></a>Navlink &amp; Redirect</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Navlink,Redirect&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br></pre></td></tr></table></figure>
<h6 id="navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签"><a href="#navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签" class="headerlink" title="navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签"></a>navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink activeClassName=<span class="string">'active'</span>exact  to=<span class="string">"/"</span>&gt;首页&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">&lt;NavLink activeClassName='active'exact  to="/</span>history<span class="string">"&gt;历史&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active' exact  to="</span>/my<span class="string">"&gt;我的&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active'exact  to="</span>/about<span class="string">"&gt;关于&lt;/NavLink&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"><a href="#有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧" class="headerlink" title="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"></a>有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧</h6><h4 id="Redirect-重定向到。。。。"><a href="#Redirect-重定向到。。。。" class="headerlink" title="Redirect 重定向到。。。。"></a>Redirect 重定向到。。。。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to =<span class="string">'/about'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span> <span class="comment">//重定向到 /about 这个路径下的 组件里</span></span><br></pre></td></tr></table></figure>
<h4 id="React-router-代码分割"><a href="#React-router-代码分割" class="headerlink" title="React-router 代码分割"></a>React-router 代码分割</h4><h6 id="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"><a href="#其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来" class="headerlink" title="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"></a>其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来</h6><h6 id="使用之前学习的const-组件-React-lazy-gt-import-……"><a href="#使用之前学习的const-组件-React-lazy-gt-import-……" class="headerlink" title="使用之前学习的const 组件 = React.lazy(()=&gt; import ……)"></a>使用之前学习的const 组件 = React.lazy(()=&gt; import ……)</h6><h4 id="React-router-滚动设置"><a href="#React-router-滚动设置" class="headerlink" title="React-router 滚动设置"></a>React-router 滚动设置</h4><h6 id="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop"><a href="#单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop" class="headerlink" title="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop"></a>单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop</h6><p>引入 useLoacation</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="comment">//在组件中就可以使用 useLoaction 的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;pathName&#125; = useLoaction();  <span class="comment">//获取到当前页面上的url 访问路径</span></span><br><span class="line">相当于浏览器中的 location 对象的 pathname 属性 location.pathname</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ScrollToTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;pathName&#125; = useLoaction();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[pathname])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们使用 useEffect 监控 访问的url pathname ,当它发生改变的时候，将滚动到页面顶部</span></span><br><span class="line">这个组件放在全局任意一个地方即可</span><br><span class="line"></span><br><span class="line">也可以放在一个单独的组件中，放在单独组件中我们就不用监控这个 访问路径了，就让它一切换到这个组件的路径就将页面滚动到顶部即可</span><br><span class="line"><span class="keyword">export</span> funtion SrcollToTop()&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[])<span class="comment">//传递空 什么都不监控，那么就会只执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取url中传递来的 参数</span></span><br><span class="line">例如页面访问 /blog/aaaa</span><br><span class="line">&lt;Route path = <span class="string">'/blog/:slug'</span>&gt;</span><br><span class="line">    <span class="comment">//这个路由渲染的组件是 blog</span></span><br><span class="line">    &lt;BlogPost/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">当访问/</span>blog/aaa 会到这个路由，进而访问到这个 blogPost 组件</span><br><span class="line">那么在 blogPost中</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;slug&#125; = useParams();  <span class="comment">// slug 就能得到url传递来的参数</span></span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更多用例查看 react-router 官网</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-router/" data-id="ckcbnl5zu000x7ow18upyolo2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-css使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-css使用/" class="article-date">
  <time datetime="2020-06-12T06:21:04.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-css使用/">react-css使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="样式引入"><a href="#样式引入" class="headerlink" title="样式引入"></a>样式引入</h4><h6 id="现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件"><a href="#现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件" class="headerlink" title="现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件"></a>现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件</h6><p>es6 中我们引入文件可以使用 import 关键字即可，坏处是这个css 会全局公用</p>
<p>第二种方式 引入 css modules 这种方式可以指定使用的是哪个 css 文件的样式，但该 css 文件的命名必须为 XXX.module.css </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Error.module.css'</span>;</span><br><span class="line"><span class="comment">//使用时可以直接 styles.文件中的样式选择器即可使用</span></span><br><span class="line"><span class="comment">//例如 css 中有一个 .error &#123;color:red&#125;</span></span><br><span class="line">style.error 即可</span><br><span class="line"><span class="comment">// 这样这个 css 就只在这个组件中生效</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>style-components</strong></p>
<h6 id="之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装"><a href="#之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装" class="headerlink" title="之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装"></a>之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装</h6><p>然后再组件中引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'style-components'</span></span><br><span class="line"><span class="comment">//然后再组件中定义这个样式</span></span><br><span class="line"><span class="keyword">const</span> Wrapper = style.footer<span class="string">`border:1px solid red`</span>; 注意这个符号</span><br><span class="line"><span class="comment">//然后 直接使用这个 Wrapper 对象即可，此时这个包帮我们生成一个footer 标签，而且应用了我们定义的css。</span></span><br><span class="line">&lt;Wrapper&gt;someThing&lt;<span class="regexp">/Wrapper&gt;</span></span><br><span class="line"><span class="regexp">反正就记住这样用就好了，定义一个对象，然后想使用什么标签就 style.标签名`css 代码`,最后直接使用这个返回的对象即可，自动应用我们``中定义的样式</span></span><br><span class="line"><span class="regexp">===================================</span></span><br><span class="line"><span class="regexp">解密：</span></span><br><span class="line"><span class="regexp">style.footer`` 其实是一个函数 ``中的内容时参数，省略了小括号</span></span><br><span class="line"><span class="regexp">let style = &#123;footer:str=&gt;console.log(str)&#125;</span></span><br><span class="line"><span class="regexp">style.footer`border:1px solid blue`</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-css使用/" data-id="ckcbnl641001v7ow1m7f3v2y8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/create-react-app/">create-react-app</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-hooks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/react-hooks/" class="article-date">
  <time datetime="2020-06-11T04:02:25.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/react-hooks/">react hooks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h6 id="让函数组件彻底取代-class-组件，解决函数组件中使用-state-生命周期函数，this的问题"><a href="#让函数组件彻底取代-class-组件，解决函数组件中使用-state-生命周期函数，this的问题" class="headerlink" title="让函数组件彻底取代 class 组件，解决函数组件中使用 state,生命周期函数，this的问题"></a>让函数组件彻底取代 class 组件，解决函数组件中使用 state,生命周期函数，this的问题</h6><p><strong>使用 reactHook(useState,useEffect) 解决这个问题</strong></p>
<p><strong>解决state</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">fucntion App()&#123;</span><br><span class="line">    <span class="comment">//组件内部useState() 返回一个数组，数组中分别是属性，set属性方法，传递的参数为属性的初始值</span></span><br><span class="line">    <span class="comment">// 此时该组件内部相当于有了一个 count 属性以及一个 setCount 方法，初始值为0;</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = userState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//改变 count 的值可以调用 setState(新值)即可，使用直接使用 count</span></span><br><span class="line">      <span class="comment">//可以有多个useState, 多个属性</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决生命周期函数 useEffect</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//一个函数参数</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = userState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个函数相当于 componentDidMount和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据挂载或更新时执行'</span>)</span><br><span class="line">    &#125;); <span class="comment">// 监控所有的 state 属性</span></span><br><span class="line"><span class="comment">//一个函数参数且该函数 return 一个函数</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'state数据挂载或更新时执行'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//相当于 componetWillUnmount,组件卸载时执行</span></span><br><span class="line">            consoel.log(<span class="string">'状态更新和写在组件时执行'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="comment">//一个函数参数，一个数组参数</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件挂载或更新时执行'</span>)</span><br><span class="line">    &#125;,[count]);</span><br><span class="line">    <span class="comment">//count 为 state 的属性，此时代表只监控count所在组件的状态，若为空数组，则不监控，若没有设置则监控state 中所有属性 也就是当这个属性的值改变时就会执行到该函数内部</span></span><br><span class="line">   <span class="comment">// 所谓卸载也就是不在引用这个state 属性了 可以这么理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现一个简单的-useState"><a href="#实现一个简单的-useState" class="headerlink" title="实现一个简单的 useState"></a>实现一个简单的 useState</h4><h6 id="模仿它的使用，定义一个函数-useState-传递参数，返回数组及方法"><a href="#模仿它的使用，定义一个函数-useState-传递参数，返回数组及方法" class="headerlink" title="模仿它的使用，定义一个函数 useState 传递参数，返回数组及方法"></a>模仿它的使用，定义一个函数 useState 传递参数，返回数组及方法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state;<span class="comment">// 定义一个属性 注意要定义在外部，否则每次调用 setState 都会给初始值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">inivalue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//因为如果多次使用这个 state,我们要保留 state 上一次的执行结果，所以要写到全局作用域中</span></span><br><span class="line">    <span class="comment">// 如果state 没有值就是用初始值 也就代表是第一次执行</span></span><br><span class="line">    state = state || initvalue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">         render()  <span class="comment">// ReactDom.render()</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> [state,setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> ReactDOM.render(</span><br><span class="line"> &lt;App /&gt;,</span><br><span class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 刚刚又犯迷糊了，函数的定义和返回结果是不一样的好吗，定义时只是形参，叫什么都行，调用时你是可以更改的呀 刚才傻逼似的 直接用返回值【state】 去了...... 而且数组只能用下标访问才对啊，怎么那么蠢</span></span><br><span class="line"><span class="comment">// 我可以直接用一个变量接收，那这个变量就是 一个数组，为了取出每一项，我可以数组【【0】赋值给一个值。。。。 为了方便可以直接使用 【a,b】 = 返回的值即可</span></span><br><span class="line"><span class="comment">// 例如 【a,b】= [1,3]  a=1,b =3; 啊啊啊啊啊</span></span><br></pre></td></tr></table></figure>
<h4 id="实现一个简单的-userEffect"><a href="#实现一个简单的-userEffect" class="headerlink" title="实现一个简单的 userEffect"></a>实现一个简单的 userEffect</h4><h4 id="最主要的就是看传递来的属性值有没有改变过，改变过就执行-callback-否则就不执行"><a href="#最主要的就是看传递来的属性值有没有改变过，改变过就执行-callback-否则就不执行" class="headerlink" title="最主要的就是看传递来的属性值有没有改变过，改变过就执行 callback,否则就不执行"></a>最主要的就是看传递来的属性值有没有改变过，改变过就执行 callback,否则就不执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldProps;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback,props</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果不是第一次执行callback并且传递了 props，那么oldProps 就会有值,此时对比新值，返回对比结果取反，(如果经过比较发生了变化，那么会返回 false,我们需要取反变为 true，这样才能继续执行 callback)如果不存在说明是第一次执行，那么 callback 肯定要被执行所以是 true</span></span><br><span class="line">    <span class="comment">// 也就是说第一次进来无论如何都会去执行 callback 的</span></span><br><span class="line">    <span class="keyword">const</span> hasChangeProps = oldProps ? !props.every(el,index=&gt; el=== oldProps[index]) : <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果没有传递这个属性或者说 传递了这个属性而且值发生了变化 就会执行这个 callback函数</span></span><br><span class="line">    <span class="comment">// 这里对props 取反来判断，如果!props 为true，则代表 props 为空，妙啊</span></span><br><span class="line">    <span class="keyword">if</span>(!props || hasChangeProps)&#123;</span><br><span class="line">         callback();</span><br><span class="line">         oldProps = props;  <span class="comment">//将新的属性值传递给一个变量保存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果传递的这个属性没有发生改变，那么久不会执行 callback</span></span><br><span class="line"><span class="comment">// 因为第一次进来这个属性假如是1，再次进来还是1， 它的值没有变过，自然不会执行(第一次还是会执行的)</span></span><br></pre></td></tr></table></figure>
<h4 id="reactHook-useState-的完整实现"><a href="#reactHook-useState-的完整实现" class="headerlink" title="reactHook-useState 的完整实现"></a>reactHook-useState 的完整实现</h4><h6 id="之前的之所以说是简单实现是因为我们只定义了一个-全局变量，加入我们有多个-useState-useEffect-那么这个变量就会被覆盖"><a href="#之前的之所以说是简单实现是因为我们只定义了一个-全局变量，加入我们有多个-useState-useEffect-那么这个变量就会被覆盖" class="headerlink" title="之前的之所以说是简单实现是因为我们只定义了一个 全局变量，加入我们有多个 useState,useEffect,那么这个变量就会被覆盖"></a>之前的之所以说是简单实现是因为我们只定义了一个 全局变量，加入我们有多个 useState,useEffect,那么这个变量就会被覆盖</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memorizState = []; <span class="comment">// 用来保存不同的 state</span></span><br><span class="line"><span class="keyword">let</span> cursor=<span class="number">0</span>; <span class="comment">//用来指向当前数组中操作的属性下标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initvalue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将初始值赋值到数组中</span></span><br><span class="line">    memorizeState[cursor] = memorizeState[cursor] || initvalue;</span><br><span class="line">    <span class="comment">//保留当前下标到当前作用域中 (闭包)</span></span><br><span class="line">    <span class="keyword">const</span> currentCursor = cursor;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">         memorizeState[currentCursor] = <span class="keyword">new</span> State;</span><br><span class="line">        render();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> [memorizedState[cursor++,setState];</span><br><span class="line">           <span class="comment">//注意这里 cursor 会先取出 然后再++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useEffect-的完整实现"><a href="#useEffect-的完整实现" class="headerlink" title="useEffect 的完整实现"></a>useEffect 的完整实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callbcak,depArray</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//取反，depArray 为空时，hasNoDep 才为true;</span></span><br><span class="line">    <span class="keyword">const</span> hasNoDeps = !depArray;</span><br><span class="line">    <span class="keyword">const</span> deps = memorizedState[cursor]; <span class="comment">//将当前的state 属性复制给这个变量</span></span><br><span class="line">    <span class="keyword">const</span> hasChangeDeps = oldProps ? !deps.every(el,index=&gt; el=== oldDeps[index]) : <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(hasNoDeps || hasChangeDeps)&#123;</span><br><span class="line">        callback()</span><br><span class="line">        memorizeState[cursor] = depArray;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/react-hooks/" data-id="ckcbnl61y00157ow1vvun8hkh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-高阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/10/react-高阶/" class="article-date">
  <time datetime="2020-06-10T08:33:42.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/10/react-高阶/">react-高阶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><h6 id="动态加载js-或者组件文件"><a href="#动态加载js-或者组件文件" class="headerlink" title="动态加载js 或者组件文件"></a>动态加载js 或者组件文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击按钮才会动态引入文件，不会再刚加载时就引入 </span></span><br><span class="line">handleClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> (<span class="string">'./advance/math'</span>).then(<span class="function">(<span class="params">math</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//使用 引入来的 js 文件中的功能</span></span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;<span class="attr">res</span>:math.add(<span class="number">3</span>,<span class="number">4</span>)&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="懒加载-可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading-等，使用时需要-suspense-标签包裹"><a href="#懒加载-可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading-等，使用时需要-suspense-标签包裹" class="headerlink" title="懒加载 可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading 等，使用时需要 suspense 标签包裹"></a>懒加载 可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading 等，使用时需要 suspense 标签包裹</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'./Button'</span>));</span><br><span class="line"></span><br><span class="line"> &lt;Suspense fallback = &#123;&lt;div&gt;Loading......&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button/</span>&gt;</span><br><span class="line"> &lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Fragments</strong></p>
<h6 id="react-要求我们的组件中的jsx-只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者-Fragment-标签包裹（这个标签不会再页面上展示，仅起到语法作用）"><a href="#react-要求我们的组件中的jsx-只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者-Fragment-标签包裹（这个标签不会再页面上展示，仅起到语法作用）" class="headerlink" title="react 要求我们的组件中的jsx 只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者 Fragment 标签包裹（这个标签不会再页面上展示，仅起到语法作用）"></a>react 要求我们的组件中的jsx 只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者 Fragment 标签包裹（这个标签不会再页面上展示，仅起到语法作用）</h6><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 组件写法  注意 <span class="title">function</span> 方式的组件不用继承 <span class="title">component</span>,手写 <span class="title">react</span>时候想想是怎么处理的，使我们手动给它创造了一个 <span class="title">class</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> 组件名称(<span class="params">props</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以写成,一样的</span><br><span class="line"><span class="keyword">const</span> 组件名 = <span class="function"><span class="params">props</span> =&gt;</span> &#123;......&#125;</span><br></pre></td></tr></table></figure>
<h6 id="react-传递数据，父组件向子组件传值通过-props-属性，层层传递"><a href="#react-传递数据，父组件向子组件传值通过-props-属性，层层传递" class="headerlink" title="react 传递数据，父组件向子组件传值通过 props 属性，层层传递"></a>react 传递数据，父组件向子组件传值通过 props 属性，层层传递</h6><h6 id="层层传递-如果层级太多，代码冗余"><a href="#层层传递-如果层级太多，代码冗余" class="headerlink" title="层层传递 如果层级太多，代码冗余"></a>层层传递 如果层级太多，代码冗余</h6><p>context 传递方式</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext();</span><br><span class="line"><span class="comment">// 在传递的组件地方 使用 这个标签 themeContext.provider 包裹 提供要传递的 value</span></span><br><span class="line">&lt;ThemeCOntext.Provider value=<span class="string">"传递的内容"</span>&gt;</span><br><span class="line"> &lt;组件/&gt;   <span class="comment">// 组件本身呢里面也包含组件a,b,c，d,我们要把这个值传递到 d上面，那么我们就在 d 中接收</span></span><br><span class="line"> &lt;<span class="regexp">/ThemeContenxt.Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在接收的组件内部定义 一个静态属性 等于这个标签对象，直接使用 this.context 获取</span></span><br><span class="line"><span class="regexp">在 d中 定义 static abc = ThemeContext</span></span><br><span class="line"><span class="regexp">使用 this.context 获取到传递过来的内容</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 注意，如果是用 function 方式写的，有一点不同之处在于，接收方无需定义 静态属性指向这个标签，直接 在 return 中使用 &lt;ThemeContext.Consumer&gt;&#123;val=&gt;(包裹这个组件的内容并且这是一个回调箭头函数,val 就是传递来的对象)&#125;&lt;/</span>Th&gt;eContext.Consumer&gt;  例如：</span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	&lt;Theme.context.consumer&gt;</span><br><span class="line">        &#123;val=&gt;(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">         	val.a,val.c......</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;<span class="regexp">/Theme.context.consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><h6 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h6><h6 id="当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于-state-中。例如："><a href="#当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于-state-中。例如：" class="headerlink" title="当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于 state 中。例如："></a>当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于 state 中。例如：</h6><h6 id="其实就是，当子组件向父组件传值时，父组件必须有一个变量来接受这个值对不，那么在-state中开辟一个变量来存储，然后写一个函数，改变state-中这个变量的值，（只有class-组件中有this）然后把这个函数传递给子组件，子组件中想传递自己的值给父组件时，通过-props-获取到这个函数，（此时这个函数中的-代码以及this-都是闭包，是父组件的this）-然后把自己的值传递给这个函数即可实现值的传递；"><a href="#其实就是，当子组件向父组件传值时，父组件必须有一个变量来接受这个值对不，那么在-state中开辟一个变量来存储，然后写一个函数，改变state-中这个变量的值，（只有class-组件中有this）然后把这个函数传递给子组件，子组件中想传递自己的值给父组件时，通过-props-获取到这个函数，（此时这个函数中的-代码以及this-都是闭包，是父组件的this）-然后把自己的值传递给这个函数即可实现值的传递；" class="headerlink" title="其实就是，当子组件向父组件传值时，父组件必须有一个变量来接受这个值对不，那么在 state中开辟一个变量来存储，然后写一个函数，改变state 中这个变量的值，（只有class 组件中有this）然后把这个函数传递给子组件，子组件中想传递自己的值给父组件时，通过 props 获取到这个函数，（此时这个函数中的 代码以及this 都是闭包，是父组件的this） 然后把自己的值传递给这个函数即可实现值的传递；"></a>其实就是，当子组件向父组件传值时，父组件必须有一个变量来接受这个值对不，那么在 state中开辟一个变量来存储，然后写一个函数，改变state 中这个变量的值，（只有class 组件中有this）然后把这个函数传递给子组件，子组件中想传递自己的值给父组件时，通过 props 获取到这个函数，（此时这个函数中的 代码以及this 都是闭包，是父组件的this） 然后把自己的值传递给这个函数即可实现值的传递；</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父组件</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">         	&lt;Son value=&#123;<span class="keyword">this</span>.state.son&#125; onChange=<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">first</span>:e.target.value&#125;)&#125;/&gt;</span><br><span class="line">			&lt;p&gt;son : &#123;<span class="keyword">this</span>.state.son&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">         &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first 组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;input value = &#123;props.value&#125; onChange=&#123;props.onChange&#125;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刚开始子组件的值是父组件通过 props 传递来的，当子组件的值发生改变时调用传递来的onchange方法，也就是父组件的 oncahnge,这个方法将子组件现在的值更新到 state 中，然后父组件中更新，又传递给子组件，达到了父组件也更新的目的</span></span><br></pre></td></tr></table></figure>
<h6 id="今天回过头来看了下子组件向父组件传值，有点疑惑，就是这个-this-的问题，所以特意打印了子组件在接受到父组件的函数，发现果然有闭包存在-子组件中保存了父组件的闭包，如下图"><a href="#今天回过头来看了下子组件向父组件传值，有点疑惑，就是这个-this-的问题，所以特意打印了子组件在接受到父组件的函数，发现果然有闭包存在-子组件中保存了父组件的闭包，如下图" class="headerlink" title="今天回过头来看了下子组件向父组件传值，有点疑惑，就是这个 this 的问题，所以特意打印了子组件在接受到父组件的函数，发现果然有闭包存在,子组件中保存了父组件的闭包，如下图"></a>今天回过头来看了下子组件向父组件传值，有点疑惑，就是这个 this 的问题，所以特意打印了子组件在接受到父组件的函数，发现果然有闭包存在,子组件中保存了父组件的闭包，如下图</h6><p><img src="../img/react/closure.png" alt></p>
<h6 id="Fist-js-是我做测试的父组件的文件名，这段代码是在自组件从props-拿到传递来的函数后打印的这个函数，所以疑惑解开了，this是父组件的，自然能修改喽；"><a href="#Fist-js-是我做测试的父组件的文件名，这段代码是在自组件从props-拿到传递来的函数后打印的这个函数，所以疑惑解开了，this是父组件的，自然能修改喽；" class="headerlink" title="Fist.js 是我做测试的父组件的文件名，这段代码是在自组件从props 拿到传递来的函数后打印的这个函数，所以疑惑解开了，this是父组件的，自然能修改喽；"></a>Fist.js 是我做测试的父组件的文件名，这段代码是在自组件从props 拿到传递来的函数后打印的这个函数，所以疑惑解开了，this是父组件的，自然能修改喽；</h6><h4 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h4><h4 id="非受控组件与Refs"><a href="#非受控组件与Refs" class="headerlink" title="非受控组件与Refs"></a>非受控组件与Refs</h4><p>如何获取要操作的这个 dom?</p>
<p><strong>第一步：</strong> 在组件内部创建一个 React.createRef() 对象，绑定到当前组件上，也就是赋值给 this.属性（在构造函数中），然后下次就可以通过 this.属性获取到这个对象了，然后在 render() 中，一般都在这里返回 dom 的，我们在需要操控的dom上加上 ref = {this.属性}</p>
<p>在需要时，就能通过 this.属性.current.  什么什么 —–  获取到这个对象了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/10/react-高阶/" data-id="ckcbnl61200117ow1bj22nxy5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-生命周期等" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/09/react-生命周期等/" class="article-date">
  <time datetime="2020-06-09T07:11:53.000Z" itemprop="datePublished">2020-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/09/react-生命周期等/">react 生命周期等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>![</p>
<p>](../img/react/cycle.png)</p>
<h6 id="这个图好糊呀-反正记住-这主要的额三个就行了"><a href="#这个图好糊呀-反正记住-这主要的额三个就行了" class="headerlink" title="这个图好糊呀  反正记住 这主要的额三个就行了"></a>这个图好糊呀  反正记住 这主要的额三个就行了</h6><p><strong>生命周期完整版如下</strong></p>
<ul>
<li>挂载时<ul>
<li>constructor()</li>
<li>render() </li>
<li>componentDidMount()</li>
</ul>
</li>
<li>更新时<ul>
<li>shouldComponentUpdate()  组件中数据更新时，return true 才会渲染</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li>卸载时<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
<li>错误处理<ul>
<li>componentDidCatch()</li>
</ul>
</li>
</ul>
<p><strong>comonentWillMount、componentWillUpdate、componentWillReceiveProps 已过时废弃</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表循环必须加key属性 </p>
<p> key属性对应的值尽量是独⼀⽆⼆的 </p>
<p>不要⽤列表序号做为key属性的值，除⾮万不得已</p>
<h6 id="key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。"><a href="#key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。" class="headerlink" title="key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。"></a>key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。</h6><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p><strong>受控组件</strong></p>
<p>state做为唯⼀数据驱动源，且⽤户对表单的操作需要反馈到 state</p>
<p>特点：表单的value由state决定，监听表单变化后从event获取新 value重新设置state</p>
<h4 id="setState-同步与异步"><a href="#setState-同步与异步" class="headerlink" title="setState 同步与异步"></a>setState 同步与异步</h4><h2 id="为什么setState有异步更新？"><a href="#为什么setState有异步更新？" class="headerlink" title="为什么setState有异步更新？"></a>为什么setState有异步更新？</h2><p>React在执行setState之后，要执行render、diff、更新DOM等一系列操作，性能开销是比较大的。加入异步更新、更新合并等策略能优化性能。</p>
<h2 id="什么时候异步更新，什么时候同步更新"><a href="#什么时候异步更新，什么时候同步更新" class="headerlink" title="什么时候异步更新，什么时候同步更新"></a>什么时候异步更新，什么时候同步更新</h2><p>组件里等事件处理程序，如 <code>onClick={this.handleClick}</code> 里面等setState是异步更新。声明生命周期函数里等setState也是异步更新。如果需要多次更新需要用异步设置等语法，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + props.count &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如setTimeout里，对原生绑定如 addEventListener 里，都是同步更新。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#btn"</span>).onclick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;.....setState(...)&#125;</span><br><span class="line">                                                          </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">this</span>.setState(...),<span class="keyword">this</span>,setState(...)&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="异步更新在效果上有什么表现"><a href="#异步更新在效果上有什么表现" class="headerlink" title="异步更新在效果上有什么表现"></a>异步更新在效果上有什么表现</h2><p>表现为更新合并，上次更新未生效。也就是如果你执行了两次 setState 它只会执行一次，因为它自己做了优化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/09/react-生命周期等/" data-id="ckcbnl5zv000y7ow1c4xl941c" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bom/">bom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/create-react-app/">create-react-app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/">dom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/">flex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https基础/">https基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js基本功/">js基本功</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobx/">mobx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue项目/">vue项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站建站案例练习/">网站建站案例练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/bom/" style="font-size: 10px;">bom</a> <a href="/tags/create-react-app/" style="font-size: 10px;">create-react-app</a> <a href="/tags/css/" style="font-size: 20px;">css</a> <a href="/tags/dom/" style="font-size: 10px;">dom</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/https基础/" style="font-size: 10px;">https基础</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/js基本功/" style="font-size: 10px;">js基本功</a> <a href="/tags/mobx/" style="font-size: 10px;">mobx</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/node-js/" style="font-size: 10px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 20px;">react</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/vue项目/" style="font-size: 10px;">vue项目</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/网站建站案例练习/" style="font-size: 10px;">网站建站案例练习</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/24/vue-account/">vue-account</a>
          </li>
        
          <li>
            <a href="/2020/06/21/react-打包发布问题记录/">react 打包发布问题记录</a>
          </li>
        
          <li>
            <a href="/2020/06/13/js-装饰器/">js 装饰器</a>
          </li>
        
          <li>
            <a href="/2020/06/13/嘚啵嘚两句-class-和-function/">嘚啵嘚两句 class 和 function</a>
          </li>
        
          <li>
            <a href="/2020/06/13/mobx/">mobx</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>