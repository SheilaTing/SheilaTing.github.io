<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>SheilaTing 的博客呀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SheilaTing 的博客呀">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SheilaTing 的博客呀">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SheilaTing 的博客呀">
  
    <link rel="alternate" href="/atom.xml" title="SheilaTing 的博客呀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SheilaTing 的博客呀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-js-装饰器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/js-装饰器/" class="article-date">
  <time datetime="2020-06-13T05:18:15.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/js-装饰器/">js 装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><code>Decorator</code> 是 ES7 的一个新语法正如其“装饰器”的叫法所表达的，他通过添加<code>@方法名</code>可以对一些对象进行装饰包装然后返回一个被包装过的对象，可以装饰的对象包括：类，属性，方法等。</strong> 在使用它之前需要引入babel模块 <code>transform-decorators-legacy</code> 编译成 ES5 或 ES6</p>
<h3 id="1-类的装饰"><a href="#1-类的装饰" class="headerlink" title="1. 类的装饰"></a>1. 类的装饰</h3><p>当装饰的对象是类时，我们操作的就是这个类本身，即装饰器函数的第一个参数，就是所要装饰的目标类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>
<h3 id="2-属性或方法的装饰"><a href="#2-属性或方法的装饰" class="headerlink" title="2. 属性或方法的装饰"></a>2. 属性或方法的装饰</h3><p><strong>对于类属性或方法的装饰本质是操作其描述符，可以把此时的装饰器理解成是 <code>Object.defineProperty(obj, prop, descriptor)</code>的语法糖。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  @readonly(<span class="literal">false</span>)</span><br><span class="line">  method() &#123; <span class="built_in">console</span>.log(<span class="string">'cat'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, key, descriptor</span>) </span>&#123; </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 此处 target 为 C.prototype; </span></span><br><span class="line"><span class="comment">	* key 为 method;</span></span><br><span class="line"><span class="comment">    * 原 descriptor 为：&#123; value: f, enumarable: false, writable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    descriptor.writable = value</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line">c.method = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'dog'</span>)</span><br><span class="line"></span><br><span class="line">c.method() <span class="comment">// cat</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = descriptor.initializer &amp;&amp; descriptor.initializer.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"-----"</span> + oldValue); </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"读取值..."</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue + <span class="string">"!"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"现在在设置值..."</span>);</span><br><span class="line">      oldValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  @observable</span><br><span class="line">  title = <span class="string">"饥⼈⾕"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="built_in">console</span>.log(app.title);</span><br><span class="line">app.title = <span class="string">"jirengu.com"</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/js-装饰器/" data-id="ckbhf7o09000p3gw1as0jjqd1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-嘚啵嘚两句-class-和-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/嘚啵嘚两句-class-和-function/" class="article-date">
  <time datetime="2020-06-13T05:10:42.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/嘚啵嘚两句-class-和-function/">嘚啵嘚两句 class 和 function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><h6 id="学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"><a href="#学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。" class="headerlink" title="学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"></a>学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。</h6><h6 id="js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用"><a href="#js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用" class="headerlink" title="js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用"></a>js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用</h6><p>今天又犯迷瞪了，还是基本功不扎实</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/嘚啵嘚两句-class-和-function/" data-id="ckbhf7o13001b3gw1b2k4g4jw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基本功/">js基本功</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mobx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/mobx/" class="article-date">
  <time datetime="2020-06-13T04:05:32.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/mobx/">mobx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h4><h6 id="之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理"><a href="#之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理" class="headerlink" title="之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理"></a>之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理</h6><h6 id="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"><a href="#上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。" class="headerlink" title="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"></a>上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。</h6><h6 id="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux"><a href="#假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux" class="headerlink" title="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux."></a>假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux.</h6><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p><strong>state</strong></p>
<h6 id="state-中保存了我们要维护的一些数据，也就是一个数据容器"><a href="#state-中保存了我们要维护的一些数据，也就是一个数据容器" class="headerlink" title="state 中保存了我们要维护的一些数据，也就是一个数据容器"></a>state 中保存了我们要维护的一些数据，也就是一个数据容器</h6><p><strong>Action</strong></p>
<h6 id="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"><a href="#如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）" class="headerlink" title="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"></a>如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）</h6><p><strong>computed value</strong> 计算属性值</p>
<h6 id="当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。"><a href="#当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。" class="headerlink" title="当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。"></a>当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。</h6><p><strong>Reaction</strong>s  反应</p>
<h6 id="当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions"><a href="#当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions" class="headerlink" title="当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions"></a>当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions</h6><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable,computed,action,autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="comment">// todos 就是要监控的数据 通过 observale 函数来生成，相当于state中的数据</span></span><br><span class="line"><span class="keyword">const</span> todos = (observable([</span><br><span class="line">    &#123;</span><br><span class="line">        title:<span class="string">'起床'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'穿衣'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'洗漱'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Computed values 这个值是通过 state 中数据得来的，当state 数据更新时，它也会更新</span></span><br><span class="line"><span class="comment">// 通过 computed()函数，操作 state 中的数据</span></span><br><span class="line"><span class="keyword">let</span> uncompletedCount = computed(<span class="function"><span class="params">()</span>=&gt;</span> todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span> !todo.completed.length);</span><br><span class="line"><span class="comment">//Reactions  当state 和 computedValue 改变时会触发 reactions</span></span><br><span class="line">  autorun = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`剩余任务：<span class="subst">$&#123;uncompletedCount&#125;</span>`</span></span><br><span class="line">        todos</span><br><span class="line">         .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line">         .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line">         .join(<span class="string">", "</span>)</span><br><span class="line">    ),</span><br><span class="line">&#125;)       </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">``</span>,.....)  <span class="comment">// console.log 可以这样写的</span></span><br><span class="line"><span class="comment">//这个方法就是 当state 和 computedvalue 变化时，会自动运行这个 autrun 函数，打印出state 中未完成的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actions  用来改变被观察者 也就是 state 中的数据</span></span><br><span class="line"><span class="keyword">const</span> doTask = action(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    todos.find(<span class="function"><span class="params">todo</span>=&gt;</span>!todo.completed).completed = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arry.find(item=&gt;) 函数 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。  一次只返回一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doTask 这个函数，因为action 本身是个函数赋值给 doTask 所以它也是个函数,只不过在action 参数中的函数中做了一些处理，来修改 state 也就是 todos 中的数据。</span></span><br></pre></td></tr></table></figure>
<h4 id="mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记"><a href="#mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记" class="headerlink" title="mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)"></a>mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun, computed, action &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line"> @observable todos = []</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(</span><br><span class="line"> <span class="string">`剩余任务:<span class="subst">$&#123;<span class="keyword">this</span>.uncompletedCount&#125;</span>`</span>,</span><br><span class="line"> <span class="keyword">this</span>.todos</span><br><span class="line"> .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line"> .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line"> .join(<span class="string">", "</span>)</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @computed get uncompletedCount() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).length;</span><br><span class="line"> &#125;</span><br><span class="line">@action addTodo(title) &#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line"> title: title,</span><br><span class="line"> completed: <span class="literal">false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @action doTask()&#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).completed = <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todo = <span class="built_in">window</span>.todo = <span class="keyword">new</span> Todo();</span><br><span class="line">todo.addTodo(<span class="string">'吃饭'</span>);</span><br><span class="line">todo.doTask()</span><br></pre></td></tr></table></figure>
<p><strong>核心思想：状态的改变引发⼀系列⾃动⾏为</strong></p>
<h4 id="react-项目中使用装饰器"><a href="#react-项目中使用装饰器" class="headerlink" title="react 项目中使用装饰器"></a>react 项目中使用装饰器</h4><p>操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create-react-app</span><br><span class="line"></span><br><span class="line">yarn eject 或者 npm run eject 暴露出配置文件</span><br><span class="line"></span><br><span class="line">yarn add @babel/plugin-proposal-decorators  //安装支持 装饰器的插件</span><br><span class="line">修改package.json， 找到 babel字段， 添加</span><br><span class="line">//查看 npm 上 plugin-proposal-decorators 包的用法</span><br><span class="line"> <span class="string">"babel"</span>: &#123;</span><br><span class="line"> <span class="string">"plugins"</span>: [</span><br><span class="line"> <span class="string">"@babel/plugin-proposal-decorators"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"presets"</span>: [</span><br><span class="line"> <span class="string">"react-app"</span></span><br><span class="line"> ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="react-mobx"><a href="#react-mobx" class="headerlink" title="react-mobx"></a>react-mobx</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/mobx/" data-id="ckbhf7o0c000q3gw178vy7e8o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobx/">mobx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-router/" class="article-date">
  <time datetime="2020-06-12T06:53:47.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-router/">react-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>npm install –save react-router-dom</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h6 id="在页面上引入所需的组件对象"><a href="#在页面上引入所需的组件对象" class="headerlink" title="在页面上引入所需的组件对象"></a>在页面上引入所需的组件对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter || HashRouter <span class="keyword">as</span> Router,</span><br><span class="line">       Switch,</span><br><span class="line">        Route,</span><br><span class="line">        Link</span><br><span class="line">       &#125;  <span class="comment">// 取别名</span></span><br><span class="line"><span class="comment">// hashRouter 和 BrowserRouter 区别是url 一个带 # 一个不带</span></span><br><span class="line"></span><br><span class="line">BrowserRouter 的作用就是声明这个组件被 router 接管了。</span><br><span class="line"><span class="comment">// 在组件 return 的 逻辑中，我们使用 &lt;Router&gt; 标签来包裹这些 路由标签，Switch,route,link 等</span></span><br><span class="line">Switch 相当于 js 中的 <span class="keyword">switch</span> 语句主要用来判断不同的条件执行不同的代码</span><br><span class="line">Route 标签则是用来渲染组件的，一般会包裹一个组件，或者在它的属性上使用 component，children 来指定要渲染的组件   </span><br><span class="line">Link 标签则是指定点击时要跳转的组件路径 很像 a 链接</span><br></pre></td></tr></table></figure>
<p><strong>下面是一个简单的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">    Switch,</span><br><span class="line">    Route,</span><br><span class="line">    Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Nav</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Link to="/</span>history<span class="string">"&gt;历史&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/my<span class="string">"&gt;我的&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/about<span class="string">"&gt;关于&lt;/Link&gt;</span></span><br><span class="line"><span class="string">            &lt;/nav&gt;</span></span><br><span class="line"><span class="string">            &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/about<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;About/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/history<span class="string">" component=&#123;History&#125;&gt;              </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/my<span class="string">" children=&#123;&lt;My/&gt;&#125;&gt;</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/home<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;Home/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/Router&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Home()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;首页&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function History()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;历史&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function My()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;我的&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function About()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;关于&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Nav;</span></span><br></pre></td></tr></table></figure>
<h6 id="当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。"><a href="#当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。" class="headerlink" title="当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。"></a>当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。</h6><h4 id="Navlink-amp-Redirect"><a href="#Navlink-amp-Redirect" class="headerlink" title="Navlink &amp; Redirect"></a>Navlink &amp; Redirect</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Navlink,Redirect&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br></pre></td></tr></table></figure>
<h6 id="navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签"><a href="#navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签" class="headerlink" title="navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签"></a>navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink activeClassName=<span class="string">'active'</span>exact  to=<span class="string">"/"</span>&gt;首页&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">&lt;NavLink activeClassName='active'exact  to="/</span>history<span class="string">"&gt;历史&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active' exact  to="</span>/my<span class="string">"&gt;我的&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active'exact  to="</span>/about<span class="string">"&gt;关于&lt;/NavLink&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"><a href="#有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧" class="headerlink" title="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"></a>有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧</h6><h4 id="Redirect-重定向到。。。。"><a href="#Redirect-重定向到。。。。" class="headerlink" title="Redirect 重定向到。。。。"></a>Redirect 重定向到。。。。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to =<span class="string">'/about'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span> <span class="comment">//重定向到 /about 这个路径下的 组件里</span></span><br></pre></td></tr></table></figure>
<h4 id="React-router-代码分割"><a href="#React-router-代码分割" class="headerlink" title="React-router 代码分割"></a>React-router 代码分割</h4><h6 id="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"><a href="#其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来" class="headerlink" title="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"></a>其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来</h6><h6 id="使用之前学习的const-组件-React-lazy-gt-import-……"><a href="#使用之前学习的const-组件-React-lazy-gt-import-……" class="headerlink" title="使用之前学习的const 组件 = React.lazy(()=&gt; import ……)"></a>使用之前学习的const 组件 = React.lazy(()=&gt; import ……)</h6><h4 id="React-router-滚动设置"><a href="#React-router-滚动设置" class="headerlink" title="React-router 滚动设置"></a>React-router 滚动设置</h4><h6 id="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop"><a href="#单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop" class="headerlink" title="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop"></a>单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop</h6><p>引入 useLoacation</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="comment">//在组件中就可以使用 useLoaction 的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;pathName&#125; = useLoaction();  <span class="comment">//获取到当前页面上的url 访问路径</span></span><br><span class="line">相当于浏览器中的 location 对象的 pathname 属性 location.pathname</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ScrollToTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;pathName&#125; = useLoaction();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[pathname])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们使用 useEffect 监控 访问的url pathname ,当它发生改变的时候，将滚动到页面顶部</span></span><br><span class="line">这个组件放在全局任意一个地方即可</span><br><span class="line"></span><br><span class="line">也可以放在一个单独的组件中，放在单独组件中我们就不用监控这个 访问路径了，就让它一切换到这个组件的路径就将页面滚动到顶部即可</span><br><span class="line"><span class="keyword">export</span> funtion SrcollToTop()&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[])<span class="comment">//传递空 什么都不监控，那么就会只执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取url中传递来的 参数</span></span><br><span class="line">例如页面访问 /blog/aaaa</span><br><span class="line">&lt;Route path = <span class="string">'/blog/:slug'</span>&gt;</span><br><span class="line">    <span class="comment">//这个路由渲染的组件是 blog</span></span><br><span class="line">    &lt;BlogPost/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">当访问/</span>blog/aaa 会到这个路由，进而访问到这个 blogPost 组件</span><br><span class="line">那么在 blogPost中</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;slug&#125; = useParams();  <span class="comment">// slug 就能得到url传递来的参数</span></span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更多用例查看 react-router 官网</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-router/" data-id="ckbhf7o0o000z3gw15owjlmkm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-css使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-css使用/" class="article-date">
  <time datetime="2020-06-12T06:21:04.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-css使用/">react-css使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="样式引入"><a href="#样式引入" class="headerlink" title="样式引入"></a>样式引入</h4><h6 id="现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件"><a href="#现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件" class="headerlink" title="现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件"></a>现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件</h6><p>es6 中我们引入文件可以使用 import 关键字即可，坏处是这个css 会全局公用</p>
<p>第二种方式 引入 css modules 这种方式可以指定使用的是哪个 css 文件的样式，但该 css 文件的命名必须为 XXX.module.css </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Error.module.css'</span>;</span><br><span class="line"><span class="comment">//使用时可以直接 styles.文件中的样式选择器即可使用</span></span><br><span class="line"><span class="comment">//例如 css 中有一个 .error &#123;color:red&#125;</span></span><br><span class="line">style.error 即可</span><br><span class="line"><span class="comment">// 这样这个 css 就只在这个组件中生效</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>style-components</strong></p>
<h6 id="之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装"><a href="#之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装" class="headerlink" title="之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装"></a>之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装</h6><p>然后再组件中引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'style-components'</span></span><br><span class="line"><span class="comment">//然后再组件中定义这个样式</span></span><br><span class="line"><span class="keyword">const</span> Wrapper = style.footer<span class="string">`border:1px solid red`</span>; 注意这个符号</span><br><span class="line"><span class="comment">//然后 直接使用这个 Wrapper 对象即可，此时这个包帮我们生成一个footer 标签，而且应用了我们定义的css。</span></span><br><span class="line">&lt;Wrapper&gt;someThing&lt;<span class="regexp">/Wrapper&gt;</span></span><br><span class="line"><span class="regexp">反正就记住这样用就好了，定义一个对象，然后想使用什么标签就 style.标签名`css 代码`,最后直接使用这个返回的对象即可，自动应用我们``中定义的样式</span></span><br><span class="line"><span class="regexp">===================================</span></span><br><span class="line"><span class="regexp">解密：</span></span><br><span class="line"><span class="regexp">style.footer`` 其实是一个函数 ``中的内容时参数，省略了小括号</span></span><br><span class="line"><span class="regexp">let style = &#123;footer:str=&gt;console.log(str)&#125;</span></span><br><span class="line"><span class="regexp">style.footer`border:1px solid blue`</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-css使用/" data-id="ckbhf7o0l000w3gw1io0fglfr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/create-react-app/">create-react-app</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-hooks" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/11/react-hooks/" class="article-date">
  <time datetime="2020-06-11T04:02:25.000Z" itemprop="datePublished">2020-06-11</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/11/react-hooks/">react hooks</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><h6 id="让函数组件彻底取代-class-组件，解决函数组件中使用-state-生命周期函数，this的问题"><a href="#让函数组件彻底取代-class-组件，解决函数组件中使用-state-生命周期函数，this的问题" class="headerlink" title="让函数组件彻底取代 class 组件，解决函数组件中使用 state,生命周期函数，this的问题"></a>让函数组件彻底取代 class 组件，解决函数组件中使用 state,生命周期函数，this的问题</h6><p><strong>使用 reactHook(useState,useEffect) 解决这个问题</strong></p>
<p><strong>解决state</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line">fucntion App()&#123;</span><br><span class="line">    <span class="comment">//组件内部useState() 返回一个数组，数组中分别是属性，set属性方法，传递的参数为属性的初始值</span></span><br><span class="line">    <span class="comment">// 此时该组件内部相当于有了一个 count 属性以及一个 setCount 方法，初始值为0;</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = userState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//改变 count 的值可以调用 setState(新值)即可，使用直接使用 count</span></span><br><span class="line">      <span class="comment">//可以有多个useState, 多个属性</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决生命周期函数 useEffect</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//一个函数参数</span></span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = userState(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//这个函数相当于 componentDidMount和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'数据挂载或更新时执行'</span>)</span><br><span class="line">    &#125;); <span class="comment">// 监控所有的 state 属性</span></span><br><span class="line"><span class="comment">//一个函数参数且该函数 return 一个函数</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'state数据挂载或更新时执行'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//相当于 componetWillUnmount,组件卸载时执行</span></span><br><span class="line">            consoel.log(<span class="string">'状态更新和写在组件时执行'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> <span class="comment">//一个函数参数，一个数组参数</span></span><br><span class="line">      useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'组件挂载或更新时执行'</span>)</span><br><span class="line">    &#125;,[count]);</span><br><span class="line">    <span class="comment">//count 为 state 的属性，此时代表只监控count所在组件的状态，若为空数组，则不监控，若没有设置则监控state 中所有属性 也就是当这个属性的值改变时就会执行到该函数内部</span></span><br><span class="line">   <span class="comment">// 所谓卸载也就是不在引用这个state 属性了 可以这么理解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实现一个简单的-useState"><a href="#实现一个简单的-useState" class="headerlink" title="实现一个简单的 useState"></a>实现一个简单的 useState</h4><h6 id="模仿它的使用，定义一个函数-useState-传递参数，返回数组及方法"><a href="#模仿它的使用，定义一个函数-useState-传递参数，返回数组及方法" class="headerlink" title="模仿它的使用，定义一个函数 useState 传递参数，返回数组及方法"></a>模仿它的使用，定义一个函数 useState 传递参数，返回数组及方法</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> state;<span class="comment">// 定义一个属性 注意要定义在外部，否则每次调用 setState 都会给初始值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">inivalue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//因为如果多次使用这个 state,我们要保留 state 上一次的执行结果，所以要写到全局作用域中</span></span><br><span class="line">    <span class="comment">// 如果state 没有值就是用初始值 也就代表是第一次执行</span></span><br><span class="line">    state = state || initvalue;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">         render()  <span class="comment">// ReactDom.render()</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> [state,setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> ReactDOM.render(</span><br><span class="line"> &lt;App /&gt;,</span><br><span class="line"> <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line"> );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 刚刚又犯迷糊了，函数的定义和返回结果是不一样的好吗，定义时只是形参，叫什么都行，调用时你是可以更改的呀 刚才傻逼似的 直接用返回值【state】 去了...... 而且数组只能用下标访问才对啊，怎么那么蠢</span></span><br><span class="line"><span class="comment">// 我可以直接用一个变量接收，那这个变量就是 一个数组，为了取出每一项，我可以数组【【0】赋值给一个值。。。。 为了方便可以直接使用 【a,b】 = 返回的值即可</span></span><br><span class="line"><span class="comment">// 例如 【a,b】= [1,3]  a=1,b =3; 啊啊啊啊啊</span></span><br></pre></td></tr></table></figure>
<h4 id="实现一个简单的-userEffect"><a href="#实现一个简单的-userEffect" class="headerlink" title="实现一个简单的 userEffect"></a>实现一个简单的 userEffect</h4><h4 id="最主要的就是看传递来的属性值有没有改变过，改变过就执行-callback-否则就不执行"><a href="#最主要的就是看传递来的属性值有没有改变过，改变过就执行-callback-否则就不执行" class="headerlink" title="最主要的就是看传递来的属性值有没有改变过，改变过就执行 callback,否则就不执行"></a>最主要的就是看传递来的属性值有没有改变过，改变过就执行 callback,否则就不执行</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldProps;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback,props</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//如果不是第一次执行callback并且传递了 props，那么oldProps 就会有值,此时对比新值，返回对比结果取反，(如果经过比较发生了变化，那么会返回 false,我们需要取反变为 true，这样才能继续执行 callback)如果不存在说明是第一次执行，那么 callback 肯定要被执行所以是 true</span></span><br><span class="line">    <span class="comment">// 也就是说第一次进来无论如何都会去执行 callback 的</span></span><br><span class="line">    <span class="keyword">const</span> hasChangeProps = oldProps ? !props.every(el,index=&gt; el=== oldProps[index]) : <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//如果没有传递这个属性或者说 传递了这个属性而且值发生了变化 就会执行这个 callback函数</span></span><br><span class="line">    <span class="comment">// 这里对props 取反来判断，如果!props 为true，则代表 props 为空，妙啊</span></span><br><span class="line">    <span class="keyword">if</span>(!props || hasChangeProps)&#123;</span><br><span class="line">         callback();</span><br><span class="line">         oldProps = props;  <span class="comment">//将新的属性值传递给一个变量保存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果传递的这个属性没有发生改变，那么久不会执行 callback</span></span><br><span class="line"><span class="comment">// 因为第一次进来这个属性假如是1，再次进来还是1， 它的值没有变过，自然不会执行(第一次还是会执行的)</span></span><br></pre></td></tr></table></figure>
<h4 id="reactHook-useState-的完整实现"><a href="#reactHook-useState-的完整实现" class="headerlink" title="reactHook-useState 的完整实现"></a>reactHook-useState 的完整实现</h4><h6 id="之前的之所以说是简单实现是因为我们只定义了一个-全局变量，加入我们有多个-useState-useEffect-那么这个变量就会被覆盖"><a href="#之前的之所以说是简单实现是因为我们只定义了一个-全局变量，加入我们有多个-useState-useEffect-那么这个变量就会被覆盖" class="headerlink" title="之前的之所以说是简单实现是因为我们只定义了一个 全局变量，加入我们有多个 useState,useEffect,那么这个变量就会被覆盖"></a>之前的之所以说是简单实现是因为我们只定义了一个 全局变量，加入我们有多个 useState,useEffect,那么这个变量就会被覆盖</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> memorizState = []; <span class="comment">// 用来保存不同的 state</span></span><br><span class="line"><span class="keyword">let</span> cursor=<span class="number">0</span>; <span class="comment">//用来指向当前数组中操作的属性下标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initvalue</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//将初始值赋值到数组中</span></span><br><span class="line">    memorizeState[cursor] = memorizeState[cursor] || initvalue;</span><br><span class="line">    <span class="comment">//保留当前下标到当前作用域中 (闭包)</span></span><br><span class="line">    <span class="keyword">const</span> currentCursor = cursor;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>)</span>&#123;</span><br><span class="line">         memorizeState[currentCursor] = <span class="keyword">new</span> State;</span><br><span class="line">        render();</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> [memorizedState[cursor++,setState];</span><br><span class="line">           <span class="comment">//注意这里 cursor 会先取出 然后再++</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useEffect-的完整实现"><a href="#useEffect-的完整实现" class="headerlink" title="useEffect 的完整实现"></a>useEffect 的完整实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callbcak,depArray</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//取反，depArray 为空时，hasNoDep 才为true;</span></span><br><span class="line">    <span class="keyword">const</span> hasNoDeps = !depArray;</span><br><span class="line">    <span class="keyword">const</span> deps = memorizedState[cursor]; <span class="comment">//将当前的state 属性复制给这个变量</span></span><br><span class="line">    <span class="keyword">const</span> hasChangeDeps = oldProps ? !deps.every(el,index=&gt; el=== oldDeps[index]) : <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(hasNoDeps || hasChangeDeps)&#123;</span><br><span class="line">        callback()</span><br><span class="line">        memorizeState[cursor] = depArray;</span><br><span class="line">    &#125;</span><br><span class="line">    cursor++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/11/react-hooks/" data-id="ckbhf7o0n000y3gw1d3nod7uy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-高阶" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/10/react-高阶/" class="article-date">
  <time datetime="2020-06-10T08:33:42.000Z" itemprop="datePublished">2020-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/10/react-高阶/">react-高阶</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h4><h6 id="动态加载js-或者组件文件"><a href="#动态加载js-或者组件文件" class="headerlink" title="动态加载js 或者组件文件"></a>动态加载js 或者组件文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点击按钮才会动态引入文件，不会再刚加载时就引入 </span></span><br><span class="line">handleClick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">import</span> (<span class="string">'./advance/math'</span>).then(<span class="function">(<span class="params">math</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="comment">//使用 引入来的 js 文件中的功能</span></span><br><span class="line">          <span class="keyword">this</span>.setState(&#123;<span class="attr">res</span>:math.add(<span class="number">3</span>,<span class="number">4</span>)&#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h6 id="懒加载-可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading-等，使用时需要-suspense-标签包裹"><a href="#懒加载-可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading-等，使用时需要-suspense-标签包裹" class="headerlink" title="懒加载 可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading 等，使用时需要 suspense 标签包裹"></a>懒加载 可以做到优雅降级，在引入文件未完全加载进来时，可以在页面展示一些预处理页面，例如Loading 等，使用时需要 suspense 标签包裹</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Button = React.lazy(<span class="function"><span class="params">()</span>=&gt;</span> <span class="keyword">import</span>(<span class="string">'./Button'</span>));</span><br><span class="line"></span><br><span class="line"> &lt;Suspense fallback = &#123;&lt;div&gt;Loading......&lt;<span class="regexp">/div&gt;&#125;&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Button/</span>&gt;</span><br><span class="line"> &lt;<span class="regexp">/Suspense&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>Fragments</strong></p>
<h6 id="react-要求我们的组件中的jsx-只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者-Fragment-标签包裹（这个标签不会再页面上展示，仅起到语法作用）"><a href="#react-要求我们的组件中的jsx-只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者-Fragment-标签包裹（这个标签不会再页面上展示，仅起到语法作用）" class="headerlink" title="react 要求我们的组件中的jsx 只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者 Fragment 标签包裹（这个标签不会再页面上展示，仅起到语法作用）"></a>react 要求我们的组件中的jsx 只能拥有一个顶级标签，为了解决这个问题我们可以使用一个空标签或者 Fragment 标签包裹（这个标签不会再页面上展示，仅起到语法作用）</h6><h4 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 组件写法  注意 <span class="title">function</span> 方式的组件不用继承 <span class="title">component</span>,手写 <span class="title">react</span>时候想想是怎么处理的，使我们手动给它创造了一个 <span class="title">class</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> 组件名称(<span class="params">props</span>)</span>&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">也可以写成,一样的</span><br><span class="line"><span class="keyword">const</span> 组件名 = <span class="function"><span class="params">props</span> =&gt;</span> &#123;......&#125;</span><br></pre></td></tr></table></figure>
<h6 id="react-传递数据，父组件向子组件传值通过-props-属性，层层传递"><a href="#react-传递数据，父组件向子组件传值通过-props-属性，层层传递" class="headerlink" title="react 传递数据，父组件向子组件传值通过 props 属性，层层传递"></a>react 传递数据，父组件向子组件传值通过 props 属性，层层传递</h6><h6 id="层层传递-如果层级太多，代码冗余"><a href="#层层传递-如果层级太多，代码冗余" class="headerlink" title="层层传递 如果层级太多，代码冗余"></a>层层传递 如果层级太多，代码冗余</h6><p>context 传递方式</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext();</span><br><span class="line"><span class="comment">// 在传递的组件地方 使用 这个标签 themeContext.provider 包裹 提供要传递的 value</span></span><br><span class="line">&lt;ThemeCOntext.Provider value=<span class="string">"传递的内容"</span>&gt;</span><br><span class="line"> &lt;组件/&gt;   <span class="comment">// 组件本身呢里面也包含组件a,b,c，d,我们要把这个值传递到 d上面，那么我们就在 d 中接收</span></span><br><span class="line"> &lt;<span class="regexp">/ThemeContenxt.Provider&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在接收的组件内部定义 一个静态属性 等于这个标签对象，直接使用 this.context 获取</span></span><br><span class="line"><span class="regexp">在 d中 定义 static abc = ThemeContext</span></span><br><span class="line"><span class="regexp">使用 this.context 获取到传递过来的内容</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 注意，如果是用 function 方式写的，有一点不同之处在于，接收方无需定义 静态属性指向这个标签，直接 在 return 中使用 &lt;ThemeContext.Consumer&gt;&#123;val=&gt;(包裹这个组件的内容并且这是一个回调箭头函数,val 就是传递来的对象)&#125;&lt;/</span>Th&gt;eContext.Consumer&gt;  例如：</span><br><span class="line"><span class="keyword">const</span> Button = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    	&lt;Theme.context.consumer&gt;</span><br><span class="line">        &#123;val=&gt;(<span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">         	val.a,val.c......</span></span><br><span class="line"><span class="xml">         <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)</span><br><span class="line">        &#125;</span><br><span class="line">        &lt;<span class="regexp">/Theme.context.consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h4><h6 id="子组件向父组件传值"><a href="#子组件向父组件传值" class="headerlink" title="子组件向父组件传值"></a>子组件向父组件传值</h6><h6 id="当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于-state-中。例如："><a href="#当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于-state-中。例如：" class="headerlink" title="当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于 state 中。例如："></a>当子组件中的数据发生变化时，调用父组件中的方法来改变，这种方式的前提是父子组件的数据源都来自于 state 中。例如：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 父组件</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;div&gt;</span><br><span class="line">         	&lt;Son value=&#123;<span class="keyword">this</span>.state.son&#125; onChange=<span class="function">(<span class="params">e</span>) =&gt;</span> &#123;<span class="keyword">this</span>.setState(&#123;<span class="attr">first</span>:e.target.value&#125;)&#125;/&gt;</span><br><span class="line">			&lt;p&gt;son : &#123;<span class="keyword">this</span>.state.son&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">         &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//first 组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">first</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">    	&lt;input value = &#123;props.value&#125; onChange=&#123;props.onChange&#125;&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刚开始子组件的值是父组件通过 props 传递来的，当子组件的值发生改变时调用传递来的onchange方法，也就是父组件的 oncahnge,这个方法将子组件现在的值更新到 state 中，然后父组件中更新，又传递给子组件，达到了父组件也更新的目的</span></span><br></pre></td></tr></table></figure>
<h4 id="错误边界"><a href="#错误边界" class="headerlink" title="错误边界"></a>错误边界</h4><h4 id="非受控组件与Refs"><a href="#非受控组件与Refs" class="headerlink" title="非受控组件与Refs"></a>非受控组件与Refs</h4><p>如何获取要操作的这个 dom?</p>
<p><strong>第一步：</strong> 在组件内部创建一个 React.createRef() 对象，绑定到当前组件上，也就是赋值给 this.属性（在构造函数中），然后下次就可以通过 this.属性获取到这个对象了，然后在 render() 中，一般都在这里返回 dom 的，我们在需要操控的dom上加上 ref = {this.属性}</p>
<p>在需要时，就能通过 this.属性.current.  什么什么 —–  获取到这个对象了</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/10/react-高阶/" data-id="ckbhf7o0w00163gw1fnc3ex1z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-生命周期等" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/09/react-生命周期等/" class="article-date">
  <time datetime="2020-06-09T07:11:53.000Z" itemprop="datePublished">2020-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/09/react-生命周期等/">react 生命周期等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>![</p>
<p>](../img/react/cycle.png)</p>
<h6 id="这个图好糊呀-反正记住-这主要的额三个就行了"><a href="#这个图好糊呀-反正记住-这主要的额三个就行了" class="headerlink" title="这个图好糊呀  反正记住 这主要的额三个就行了"></a>这个图好糊呀  反正记住 这主要的额三个就行了</h6><p><strong>生命周期完整版如下</strong></p>
<ul>
<li>挂载时<ul>
<li>constructor()</li>
<li>render() </li>
<li>componentDidMount()</li>
</ul>
</li>
<li>更新时<ul>
<li>shouldComponentUpdate()  组件中数据更新时，return true 才会渲染</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li>卸载时<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
<li>错误处理<ul>
<li>componentDidCatch()</li>
</ul>
</li>
</ul>
<p><strong>comonentWillMount、componentWillUpdate、componentWillReceiveProps 已过时废弃</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表循环必须加key属性 </p>
<p> key属性对应的值尽量是独⼀⽆⼆的 </p>
<p>不要⽤列表序号做为key属性的值，除⾮万不得已</p>
<h6 id="key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。"><a href="#key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。" class="headerlink" title="key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。"></a>key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。</h6><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p><strong>受控组件</strong></p>
<p>state做为唯⼀数据驱动源，且⽤户对表单的操作需要反馈到 state</p>
<p>特点：表单的value由state决定，监听表单变化后从event获取新 value重新设置state</p>
<h4 id="setState-同步与异步"><a href="#setState-同步与异步" class="headerlink" title="setState 同步与异步"></a>setState 同步与异步</h4><h2 id="为什么setState有异步更新？"><a href="#为什么setState有异步更新？" class="headerlink" title="为什么setState有异步更新？"></a>为什么setState有异步更新？</h2><p>React在执行setState之后，要执行render、diff、更新DOM等一系列操作，性能开销是比较大的。加入异步更新、更新合并等策略能优化性能。</p>
<h2 id="什么时候异步更新，什么时候同步更新"><a href="#什么时候异步更新，什么时候同步更新" class="headerlink" title="什么时候异步更新，什么时候同步更新"></a>什么时候异步更新，什么时候同步更新</h2><p>组件里等事件处理程序，如 <code>onClick={this.handleClick}</code> 里面等setState是异步更新。声明生命周期函数里等setState也是异步更新。如果需要多次更新需要用异步设置等语法，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + props.count &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如setTimeout里，对原生绑定如 addEventListener 里，都是同步更新。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#btn"</span>).onclick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;.....setState(...)&#125;</span><br><span class="line">                                                          </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">this</span>.setState(...),<span class="keyword">this</span>,setState(...)&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="异步更新在效果上有什么表现"><a href="#异步更新在效果上有什么表现" class="headerlink" title="异步更新在效果上有什么表现"></a>异步更新在效果上有什么表现</h2><p>表现为更新合并，上次更新未生效。也就是如果你执行了两次 setState 它只会执行一次，因为它自己做了优化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/09/react-生命周期等/" data-id="ckbhf7o0m000x3gw1k9uutc3d" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-手写-react" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/06/手写-react/" class="article-date">
  <time datetime="2020-06-06T08:07:31.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/06/手写-react/">手写 react</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><h6 id="javascript-语法扩展，用于形象描述一段DOM结构"><a href="#javascript-语法扩展，用于形象描述一段DOM结构" class="headerlink" title="javascript 语法扩展，用于形象描述一段DOM结构"></a>javascript 语法扩展，用于形象描述一段DOM结构</h6><p>例如:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"hello"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      <span class="comment">// 这就是一行 jsx 代码</span></span><br></pre></td></tr></table></figure>
<h6 id="React-推荐使用JSX-但是很明显这么一行JSX-代码是无法在浏览器中运行的。那么我们使用-babel-打包工具来处理我们的代码，babel-会把jsx-转换为-React-createElement-tag-attr-children-那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement-方法，所以为了运行不报错，我们需要定义一个-React-对象，并创建一个-createElement-方法-而babel-帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx-代码一一对应，也就babel把我们页面上的jsx-代码转换为了这三个参数；这三个参数分别是-jsx-代码的-标签（顶级标签）-以及标签上的属性，还有标签里面的内容（一个数组）"><a href="#React-推荐使用JSX-但是很明显这么一行JSX-代码是无法在浏览器中运行的。那么我们使用-babel-打包工具来处理我们的代码，babel-会把jsx-转换为-React-createElement-tag-attr-children-那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement-方法，所以为了运行不报错，我们需要定义一个-React-对象，并创建一个-createElement-方法-而babel-帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx-代码一一对应，也就babel把我们页面上的jsx-代码转换为了这三个参数；这三个参数分别是-jsx-代码的-标签（顶级标签）-以及标签上的属性，还有标签里面的内容（一个数组）" class="headerlink" title="React 推荐使用JSX,但是很明显这么一行JSX 代码是无法在浏览器中运行的。那么我们使用 babel 打包工具来处理我们的代码，babel 会把jsx 转换为 React.createElement(tag,attr,children);那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement 方法，所以为了运行不报错，我们需要定义一个 React 对象，并创建一个 createElement 方法,而babel 帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx 代码一一对应，也就babel把我们页面上的jsx 代码转换为了这三个参数；这三个参数分别是 jsx 代码的 标签（顶级标签）, 以及标签上的属性，还有标签里面的内容（一个数组）;"></a>React 推荐使用JSX,但是很明显这么一行JSX 代码是无法在浏览器中运行的。那么我们使用 babel 打包工具来处理我们的代码，babel 会把jsx 转换为 React.createElement(tag,attr,children);那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement 方法，所以为了运行不报错，我们需要定义一个 React 对象，并创建一个 createElement 方法,而babel 帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx 代码一一对应，也就babel把我们页面上的jsx 代码转换为了这三个参数；这三个参数分别是 jsx 代码的 标签（顶级标签）, 以及标签上的属性，还有标签里面的内容（一个数组）;</h6><h6 id="那我们拿到这三个参数之后，自定义-createElement-方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React-核心就在这块。"><a href="#那我们拿到这三个参数之后，自定义-createElement-方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React-核心就在这块。" class="headerlink" title="那我们拿到这三个参数之后，自定义 createElement 方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React 核心就在这块。"></a>那我们拿到这三个参数之后，自定义 createElement 方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React 核心就在这块。</h6><p> webpack config.js 中配置了 js 或者 jsx文件，会使用 babel 来加载</p>
<p> babel 会把代码转换为 let div = React.createElement(tag,attr,childrenNode)</p>
<p> 如果 createElement 方法不返回，那么 consoel.log(div) 就是 undefined</p>
<p> 所以 我们把 babel 帮我们生成的这个方法的三个参数，这三个参数分别对应我们 html 的 标签，属性，和内容（以及标签嵌套的字标签）</p>
<p> 所以我们把这些内容返回出去，那么 div 就可以接收到这三个参数，做进一步处理</p>
<p> 就变成 let div = { tag,attr,child }</p>
<p>那么很显然如果我们直接打开生成的 index.html 会报错找不到 React,所以，我们需要定义一个 React</p>
<p> webpack config.js 中配置了 js 或者 jsx文件，会使用 babel 来加载</p>
<p> babel 会把代码转换为 let div = React.createElement(tag,attr,childrenNode)</p>
<p> 如果 createElement 方法不返回，那么 consoel.log(div) 就是 undefined</p>
<p> 所以 我们把 babel 帮我们生成的这个方法的三个参数，这三个参数分别对应我们 html 的 标签，属性，和内容（以及标签嵌套的字标签）</p>
<p> 所以我们把这些内容返回出去，那么 div 就可以接收到这三个参数，做进一步处理</p>
<p> 就变成 let div = { tag,attr,child }</p>
<p> 那么很显然如果我们直接打开生成的 index.html 会报错找不到 React,所以，我们需要定义一个 React</p>
<p>现在 这个 div 通过 babel 以及 react.createElment 方法已经成为了一个 携带 tag,attr,children 的对象</p>
<p>那么我们就可以通过这三个对象，将这个div 像html 一样展示在浏览器中</p>
<p>具体就是，我们定义一个方法，把这个div 以及document.body 传递进去，经过处理</p>
<p>拿到 dom 也就是我们这个 div对象后，我们取出里面的 tag</p>
<p>判断dom 的类型,当这个对象没有被标签包裹时，它是一个 string 字符串，可以打印出来看看</p>
<p>如果是字符串，那么直接创建一个 textnode</p>
<p>当有标签包裹时，它是一个 object</p>
<p>处理 属性 传递 节点 和 vdom 上的属性。。。。。。</p>
<p><strong>## 实现自定义标签的渲染</strong></p>
<p> 前面我们通过 babel 已经实现了将 普通的 jsx 转换为 React.createElement(tag,attr,children) </p>
<p> 然后拿到这个生成的虚拟dom,通过定义的 React.render() 方法将tag,attr,children 以标准的 html 的形式展示到了页面上</p>
<p> 那么下一步我们如果想在页面上展示自己定义的标签需要怎么做呢？也就是不是html 内置的这些标签，而是自定义的一些语义化的标签模块</p>
<p> 例如 <app></app> <menue></menue> ……</p>
<p> 根据 babel 的知识，我们知道，它会把这样的标签内容渲染称为 React.createElement(App,attr,children)</p>
<p> 注意这里的 App 不带引号，也就是说它不是一个html 标签，而是一个变量。如果我们直接把它放入页面势必会报错，因为我们没有定义 App</p>
<p> 这个对象，所以我们要定义这个对象 App </p>
<p> 定义好这个对象之后，为了实现内容的渲染，我们可以在 App 对象中定义一个 render() 方法，返回我们要渲染的 html 或者 jsx;</p>
<p> 这样在我们执行 ReactDom.render() 方法时，如果遇到了这样自定义的标签，那么我们就可以 new 一个我们定义好的 APP 对象，然后调用这个对象的 render() 方法 返回一个 html或者 jsx dom,然后我们在解析这个 返回值 不就可以实现了吗</p>
<p> 好了，开始写。。。。。。</p>
<p> 在设置好 state 对象的值后，如果想要有效果需要重新渲染页面，具体就是拿到这个state 所在的组件对象，然后根据新的state 创建新的dom,然后做一下替换即可</p>
<p> 接下来我们要实现一个函数式的组件，也就是es3 的写法的函数 function 组件名,我来重新捋一遍哈,如果是我们自定义的标签而非是 html 标签，babel 会帮助我们转换为 React.createElement(tag,attr,children),这样的形式，那么这个 tag 就是一个变量，而非一个 html 字符串标签，我们需要定义这个 变量对象否则运行就会报错</p>
<p> 前面我们使用es6的方法定义了class 对象，那如果我们使用 es3 function 方法定义呢?那我们上面写的逻辑是获取该组件上的 render() 方法获取我们的 jsx dom,现在改为 function 写法，里面不能再嵌套方法了，只能使用.prototype 的方式添加这个函数，而我们也没有定义这个方法，该如果获取到这个 render 里面的内容呢?</p>
<p> 思路哈： 当我们监测到要渲染的是一个 function 的时候，我们来判断这个对象是一个 function 还是一个 class，根据我们 class 的写法，我们是让这个组件继承了 React.component 这个对象的，那也就意味着 class 对象的 prototype == React.component 对吧, 而 function 方法写的则不会有，所以可以根据这个来判断</p>
<p> 我们可以定义一个处理这个对象的方法，传递这个 tag 标签，返回一个 class 对象(后续逻辑需要)</p>
<p> 那么如果是 class 方式写的，就直接 new 这个对象即可，如果是 function 方法写的，我们需要构造一个render() 方法，并且赋值给一个class，最后 new 这个 class,这样就解决啦,好啦，开写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/06/手写-react/" data-id="ckbhf7o15001d3gw1pastvxrb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/01/webpack-笔记/" class="article-date">
  <time datetime="2020-06-01T07:25:41.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/01/webpack-笔记/">webpack 笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h6 id="静态模块打包器"><a href="#静态模块打包器" class="headerlink" title="静态模块打包器"></a>静态模块打包器</h6><h6 id="根据文档学习"><a href="#根据文档学习" class="headerlink" title="根据文档学习"></a>根据文档学习</h6><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><h6 id="使用-webpack-命令时，可以指定webpack的配置文件，webpack-–config-webpack-config-js-该命令可以简写为-webpack，它会默认去找这个名称的配置文件"><a href="#使用-webpack-命令时，可以指定webpack的配置文件，webpack-–config-webpack-config-js-该命令可以简写为-webpack，它会默认去找这个名称的配置文件" class="headerlink" title="使用 webpack 命令时，可以指定webpack的配置文件，webpack –config webpack.config.js,该命令可以简写为 webpack，它会默认去找这个名称的配置文件"></a>使用 webpack 命令时，可以指定webpack的配置文件，webpack –config webpack.config.js,该命令可以简写为 webpack，它会默认去找这个名称的配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">     <span class="string">"build"</span>:<span class="string">"webpack"</span>  </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js 部分内容</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,  <span class="comment">//指定打包后的文件名称,在入口html中引入即可</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>)   <span class="comment">//文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="有一个概念你必须清楚的就是-我们的项目目录，分为-src-源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。"><a href="#有一个概念你必须清楚的就是-我们的项目目录，分为-src-源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。" class="headerlink" title="有一个概念你必须清楚的就是,我们的项目目录，分为 src 源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。"></a>有一个概念你必须清楚的就是,我们的项目目录，分为 src 源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。</h6><h4 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h4><h6 id="htmlwebpackPlugin-帮助我们生成-dist-下的index-html-也就是最终运行的html-并且将打包后的js文件引入该-html"><a href="#htmlwebpackPlugin-帮助我们生成-dist-下的index-html-也就是最终运行的html-并且将打包后的js文件引入该-html" class="headerlink" title="htmlwebpackPlugin 帮助我们生成 dist 下的index.html,(也就是最终运行的html)并且将打包后的js文件引入该 html."></a>htmlwebpackPlugin 帮助我们生成 dist 下的index.html,(也就是最终运行的html)并且将打包后的js文件引入该 html.</h6><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p><strong>inline-source-map</strong></p>
<h6 id="webpack-config-js-中-配置-dev-tool-inline-source-map-作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员"><a href="#webpack-config-js-中-配置-dev-tool-inline-source-map-作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员" class="headerlink" title="webpack.config.js 中 配置 dev-tool:inline-source-map,作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员"></a>webpack.config.js 中 配置 dev-tool:inline-source-map,作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员</h6><hr>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><h6 id="刚发现-webpack-dev-server-执行后并不会在本地生成-dist-文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server-，而在生产环境，我们直接执行-npx-webpack-打包好代码，这个命令会在当前目录生成-dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。"><a href="#刚发现-webpack-dev-server-执行后并不会在本地生成-dist-文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server-，而在生产环境，我们直接执行-npx-webpack-打包好代码，这个命令会在当前目录生成-dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。" class="headerlink" title="刚发现 webpack-dev-server 执行后并不会在本地生成 dist 文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server ，而在生产环境，我们直接执行 npx webpack 打包好代码，这个命令会在当前目录生成 dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。"></a>刚发现 webpack-dev-server 执行后并不会在本地生成 dist 文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server ，而在生产环境，我们直接执行 npx webpack 打包好代码，这个命令会在当前目录生成 dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。</h6><p>刚刚使用 webpack-dev-server 纳闷了半天 dist 为何是空的</p>
<p>也就是说：我们引入 htmlwebpackplugin 插件 这个插件会生成dist文件夹，并且在里面生成 index.html,并且引入相关打包后的js,以及我们引入的 cleanwebpackplugin 插件，清理 dist文件夹，都是为了我们的生产环境而引入的。我这样理解没错吧，可为何，安装包时放到了 dev中，为了开发测试？</p>
<h4 id="HMR-（hot-module-replacement）-模块热更新）（仅限开发环境使用）"><a href="#HMR-（hot-module-replacement）-模块热更新）（仅限开发环境使用）" class="headerlink" title="HMR （hot module replacement） 模块热更新）（仅限开发环境使用）"></a>HMR （hot module replacement） 模块热更新）（仅限开发环境使用）</h4><p>它允许在运行时更新各种模块，而无需进行完全刷新，即只变动你修改的地方，其他的代码还保留之前的状态。</p>
<p>启用这个功能需要配合 webpack-dev-server 一起使用。</p>
<h6 id="使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码："><a href="#使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码：" class="headerlink" title="使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码："></a>使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在要热更细的模块中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;  <span class="comment">//判断是否开启了热更新</span></span><br><span class="line"><span class="comment">//热更新功能接受print.js的变动的更新,即只刷新print.js 中的变动，其他代码状态不会被刷新</span></span><br><span class="line"><span class="comment">// 例如，入口文件中有一个变量i,每次执行都会++，你会发现当接受print.js的热更新后，入口文件中的 i还是会从它上次执行的地方开始++，而不是从初始值（例如1）开始；这就是热更新</span></span><br><span class="line">	<span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//回调函数</span></span><br><span class="line">		</span><br><span class="line">	&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h4><h6 id="你可以将应用程序想象成一棵树。绿色表示实际用到的源码和-library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。"><a href="#你可以将应用程序想象成一棵树。绿色表示实际用到的源码和-library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。" class="headerlink" title="你可以将应用程序想象成一棵树。绿色表示实际用到的源码和 library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。"></a>你可以将应用程序想象成一棵树。绿色表示实际用到的源码和 library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</h6><p>结论： 在生产环境下，加入  mode: “production” 就会自动将无用的代码给去除，减小体积，提高效率</p>
<p>例如，在a.js 中有export 出了两个函数，但只被引用了一个函数，但打包后，你会发现打包后的代码中依旧是包含未使用的函数的，加入这个配置后，就会只引入使用的这个函数；binggo</p>
<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><h6 id="开发环境-development-和生产环境-production-的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载-live-reloading-或热模块替换-hot-module-replacement-能力的-source-map-和-localhost-server。而在生产环境中，我们的目标则转向于关注更小的-bundle，更轻量的-source-map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的-webpack-配置"><a href="#开发环境-development-和生产环境-production-的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载-live-reloading-或热模块替换-hot-module-replacement-能力的-source-map-和-localhost-server。而在生产环境中，我们的目标则转向于关注更小的-bundle，更轻量的-source-map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的-webpack-配置" class="headerlink" title="开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置"></a><em>开发环境(development)</em>和<em>生产环境(production)</em>的构建目标差异很大。在<em>开发环境</em>中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在<em>生产环境</em>中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong></h6><p>使用参考官方文档</p>
<p>思路：拆分 webpack.config.js</p>
<p>开发环境：webpack-dev.js</p>
<p>生产环境： webpack-prod.js</p>
<p>common.js ：包含生产和开发环境都需要的公共的一些配置</p>
<p>下载一个 merge 包，用来根据不同的环境  —- 开发环境（或者生产环境）的js 和 common.js 合并</p>
<p>在package.js scripts 中设置脚本，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">scripts:&#123;</span><br><span class="line">    <span class="string">"start"</span>:<span class="string">"webpack-dev-server --open --config webpack.dev.js"</span> , <span class="comment">//启动 webpackserver 并且是通过开发环境的配置文件启动的</span></span><br><span class="line">    <span class="string">"build"</span>:<span class="string">"webpack --config webpack.prod.js"</span>  <span class="comment">//生产环境的配置文件，生产环境是不需要启动webpackserver的，所以就是这样喽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定环境"><a href="#指定环境" class="headerlink" title="指定环境"></a>指定环境</h4><p>任何位于 <code>/src</code> 的本地代码都可以关联到 process.env.NODE_ENV 环境变量，所以以下检查也是有效的</p>
<p>配置环境的步骤如下：</p>
<p>在相应的webpack配置文件中写上，例如在dev.js 中写 development</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env.NODE_ENV'</span>:<span class="built_in">JSON</span>.stringify(<span class="string">'development'</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>这样，你执行 该文件的话，就会获得当前配置的环境名称，然后做判断，例如打印日志什么的</p>
<p>在 src下的文件中都可以访问到该 类似全局变量的这个环境配置</p>
<h4 id="代码分离-好处就是可以把共有的东西抽离出来"><a href="#代码分离-好处就是可以把共有的东西抽离出来" class="headerlink" title="代码分离 好处就是可以把共有的东西抽离出来"></a>代码分离 好处就是可以把共有的东西抽离出来</h4><h6 id="代码分离就是可以把不同的文件打包到不同的bundle-js中，例如之前配置的-多个-entry-以及output"><a href="#代码分离就是可以把不同的文件打包到不同的bundle-js中，例如之前配置的-多个-entry-以及output" class="headerlink" title="代码分离就是可以把不同的文件打包到不同的bundle.js中，例如之前配置的 多个 entry,以及output"></a>代码分离就是可以把不同的文件打包到不同的bundle.js中，例如之前配置的 多个 entry,以及output</h6><p>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中</p>
<p>但这种方式需要我们手动配置太麻烦，而且还会有一个问题，例如这两个入口文件中都引用了jquery,那么最终生成的两个 bundle.js 中都会包含 jquery,这样无疑文件体积会大很多，怎么解决呢，就是把共有的juqery 提取出来，其他模块需要，引入即可。</p>
<p>具体解决方案：CommonsChunkPlugin</p>
<p>这个插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk</p>
<p>使用步骤见官网文档</p>
<p><strong>动态导入</strong></p>
<h6 id="就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入"><a href="#就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入" class="headerlink" title="就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入"></a>就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入</h6><p>这时候，我们不用指定多个入口，配置好后，通过动态引入这个公用的库，它会自动生成一个公用的js</p>
<p>使用 import 函数 promise 风格的函数</p>
<p>参见官网</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p><strong>webpack 为何需要多个入口文件和输出文件？</strong></p>
<h6 id="答：项目中肯定不止一个html页面，a页面需要引入a-js，b-js，c-js-在入口文件中require-a页面需要的js文件即可。"><a href="#答：项目中肯定不止一个html页面，a页面需要引入a-js，b-js，c-js-在入口文件中require-a页面需要的js文件即可。" class="headerlink" title="答：项目中肯定不止一个html页面，a页面需要引入a.js，b.js，c.js 在入口文件中require a页面需要的js文件即可。"></a>答：项目中肯定不止一个html页面，a页面需要引入a.js，b.js，c.js 在入口文件中require a页面需要的js文件即可。</h6><h6 id="b页面需要引入d-js-，e-js-，f-js-，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？"><a href="#b页面需要引入d-js-，e-js-，f-js-，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？" class="headerlink" title="b页面需要引入d.js ，e.js ，f.js ，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？"></a>b页面需要引入d.js ，e.js ，f.js ，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？</h6><h6 id="这就像是不同的模块需要不同的js一样"><a href="#这就像是不同的模块需要不同的js一样" class="headerlink" title="这就像是不同的模块需要不同的js一样"></a>这就像是不同的模块需要不同的js一样</h6><h4 id="自己创建-loader"><a href="#自己创建-loader" class="headerlink" title="自己创建 loader"></a>自己创建 loader</h4><h6 id="自己手写一个loader-需要在-webpack配置文件中指定loader的路径，有需要可以配置一些-options"><a href="#自己手写一个loader-需要在-webpack配置文件中指定loader的路径，有需要可以配置一些-options" class="headerlink" title="自己手写一个loader,需要在 webpack配置文件中指定loader的路径，有需要可以配置一些 options"></a>自己手写一个loader,需要在 webpack配置文件中指定loader的路径，有需要可以配置一些 options</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//指定loader 目录</span></span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        modules: [</span><br><span class="line">            <span class="string">'node_mdules'</span>,</span><br><span class="line">            path.resolve(__dirname, <span class="string">'loaders'</span>)</span><br><span class="line">        ]</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果不在上面统一指明 loaders目录，那么就要像下面这样写全路径</span></span><br><span class="line">                        <span class="comment">// loader:path.resolve(__dirname,'loaders/replace.js'),</span></span><br><span class="line">                        <span class="comment">//如果已经制定了loader的目录那么这里loader直接写</span></span><br><span class="line">                        loader:<span class="string">"replace"</span>,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            name:<span class="string">'abc'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h6 id="loader-的编写"><a href="#loader-的编写" class="headerlink" title="loader 的编写"></a>loader 的编写</h6><h6 id="所谓-loader-只是一个导出为函数的-JavaScript-模块，（官网介绍的特别详细）loader-runner-会调用这个函数，然后把上一个-loader-产生的结果或者资源文件-resource-file-传入进去。函数的-this-上下文将由-webpack-填充，并且-loader-runner-具有一些有用方法，可以使-loader-改变为异步调用方式，或者获取-query-参数。"><a href="#所谓-loader-只是一个导出为函数的-JavaScript-模块，（官网介绍的特别详细）loader-runner-会调用这个函数，然后把上一个-loader-产生的结果或者资源文件-resource-file-传入进去。函数的-this-上下文将由-webpack-填充，并且-loader-runner-具有一些有用方法，可以使-loader-改变为异步调用方式，或者获取-query-参数。" class="headerlink" title="所谓 loader 只是一个导出为函数的 JavaScript 模块，（官网介绍的特别详细）loader runner 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 this 上下文将由 webpack 填充，并且 loader runner 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。"></a>所谓 loader 只是一个导出为函数的 JavaScript 模块，（官网介绍的特别详细）<a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">loader runner</a> 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 <code>this</code> 上下文将由 webpack 填充，并且 <a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">loader runner</a> 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// testLoader.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source,map,meta</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//source 就是我们在配置文件中，设置匹配正则表达式的文件，而在loader 中 我们要做的事情就是，通过我们自己的一些个性化处理，来处理这个 source,然后返回出去</span></span><br><span class="line">    doSomeThing(csource)</span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options 就是webpackconfig.js中loader配置的 options 参数</span></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自己创建-plugin"><a href="#自己创建-plugin" class="headerlink" title="自己创建 plugin"></a>自己创建 plugin</h4><h6 id="插件能够-钩入-hook-到在每个编译-compilation-中触发的所有关键事件。在编译的每一步，插件都具备完全访问-compiler-对象的能力，如果情况合适，还可以访问当前-compilation-对象。"><a href="#插件能够-钩入-hook-到在每个编译-compilation-中触发的所有关键事件。在编译的每一步，插件都具备完全访问-compiler-对象的能力，如果情况合适，还可以访问当前-compilation-对象。" class="headerlink" title="插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。"></a>插件能够 <a href="https://www.webpackjs.com/api/compiler-hooks/#hooks" target="_blank" rel="noopener">钩入(hook)</a> 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 <code>compiler</code> 对象的能力，如果情况合适，还可以访问当前 <code>compilation</code> 对象。</h6><p>就是在编译过程的某个阶段做一些特定的事情</p>
<p><code>webpack</code> 插件由以下组成：</p>
<ul>
<li>一个 JavaScript 命名函数</li>
<li>在插件函数的 prototype 上定义一个 <code>apply</code> 方法。</li>
<li>指定一个绑定到 webpack 自身的<a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">事件钩子</a></li>
<li>处理 webpack 内部实例的特定数据</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本构架  es3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloPlugin</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compiler 对象是webpack 创建的一个对象，可以访问到webpack构建的每个过程,</span></span><br><span class="line">HelloPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//compiler 在执行过程中，可以获得当前过程中的 编译过程对象 compilation</span></span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'helloPlugin'</span>,compilation=&gt;&#123;</span><br><span class="line">        <span class="comment">//做一些事情</span></span><br><span class="line">        consoel.log(<span class="string">'do something here'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = HelloPlugin</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">         compiler.hooks.done.tap(<span class="string">'helloPlugin'</span>,compilation=&gt;&#123;</span><br><span class="line">        consoel.log(<span class="string">'do something here'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloPlugin</span><br></pre></td></tr></table></figure>
<p><strong>哎，具体，我们也没学明白，就知道，先这样用起来</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/01/webpack-笔记/" data-id="ckbhf7o0t00143gw17a62tbx2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bom/">bom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/create-react-app/">create-react-app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/">dom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https基础/">https基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js基本功/">js基本功</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobx/">mobx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站建站案例练习/">网站建站案例练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/bom/" style="font-size: 10px;">bom</a> <a href="/tags/create-react-app/" style="font-size: 10px;">create-react-app</a> <a href="/tags/css/" style="font-size: 20px;">css</a> <a href="/tags/dom/" style="font-size: 10px;">dom</a> <a href="/tags/http/" style="font-size: 13.33px;">http</a> <a href="/tags/https基础/" style="font-size: 10px;">https基础</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/js基本功/" style="font-size: 10px;">js基本功</a> <a href="/tags/mobx/" style="font-size: 10px;">mobx</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/node-js/" style="font-size: 10px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 16.67px;">react</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/webpack/" style="font-size: 13.33px;">webpack</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/网站建站案例练习/" style="font-size: 10px;">网站建站案例练习</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/13/js-装饰器/">js 装饰器</a>
          </li>
        
          <li>
            <a href="/2020/06/13/嘚啵嘚两句-class-和-function/">嘚啵嘚两句 class 和 function</a>
          </li>
        
          <li>
            <a href="/2020/06/13/mobx/">mobx</a>
          </li>
        
          <li>
            <a href="/2020/06/12/react-router/">react-router</a>
          </li>
        
          <li>
            <a href="/2020/06/12/react-css使用/">react-css使用</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>