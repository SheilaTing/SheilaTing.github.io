<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>SheilaTing 的博客呀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SheilaTing 的博客呀">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SheilaTing 的博客呀">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SheilaTing 的博客呀">
  
    <link rel="alternate" href="/atom.xml" title="SheilaTing 的博客呀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SheilaTing 的博客呀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-react-生命周期等" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/09/react-生命周期等/" class="article-date">
  <time datetime="2020-06-09T07:11:53.000Z" itemprop="datePublished">2020-06-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/09/react-生命周期等/">react 生命周期等</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>![</p>
<p>](../img/react/cycle.png)</p>
<h6 id="这个图好糊呀-反正记住-这主要的额三个就行了"><a href="#这个图好糊呀-反正记住-这主要的额三个就行了" class="headerlink" title="这个图好糊呀  反正记住 这主要的额三个就行了"></a>这个图好糊呀  反正记住 这主要的额三个就行了</h6><p><strong>生命周期完整版如下</strong></p>
<ul>
<li>挂载时<ul>
<li>constructor()</li>
<li>render() </li>
<li>componentDidMount()</li>
</ul>
</li>
<li>更新时<ul>
<li>shouldComponentUpdate()  组件中数据更新时，return true 才会渲染</li>
<li>render()</li>
<li>componentDidMount()</li>
</ul>
</li>
<li>卸载时<ul>
<li>componentWillUnmount()</li>
</ul>
</li>
<li>错误处理<ul>
<li>componentDidCatch()</li>
</ul>
</li>
</ul>
<p><strong>comonentWillMount、componentWillUpdate、componentWillReceiveProps 已过时废弃</strong></p>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表循环必须加key属性 </p>
<p> key属性对应的值尽量是独⼀⽆⼆的 </p>
<p>不要⽤列表序号做为key属性的值，除⾮万不得已</p>
<h6 id="key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。"><a href="#key-是用来在渲染页面时做-diff-算法的，一般选择一个独一无二的值，不推荐使用数据的下标-0-1-2……-因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是-0-1-2-3-4-5-无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新-例如原来数组-1-2-3-新数组-0-1-2-3-原来-1的下标为0key-0-现在-1的-key-为1，这就起不到diff-的作用了，相当于白加，它还会用它默认的算法来对比。" class="headerlink" title="key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。"></a>key 是用来在渲染页面时做 diff 算法的，一般选择一个独一无二的值，不推荐使用数据的下标 0,1,2…… 因为在做diff时候，会把key拿出来跟上次的对比，（如果有就直接拿出来用）如果那数组中的下标都是 0,1,2,3,4,5 无论数组中的内容怎么变化，所以这样就达不到对比的效果了，都会更新 例如原来数组 1,2,3 新数组 0,1,2,3 原来 1的下标为0key=0 现在 1的 key 为1，这就起不到diff 的作用了，相当于白加，它还会用它默认的算法来对比。</h6><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p><strong>受控组件</strong></p>
<p>state做为唯⼀数据驱动源，且⽤户对表单的操作需要反馈到 state</p>
<p>特点：表单的value由state决定，监听表单变化后从event获取新 value重新设置state</p>
<h4 id="setState-同步与异步"><a href="#setState-同步与异步" class="headerlink" title="setState 同步与异步"></a>setState 同步与异步</h4><h2 id="为什么setState有异步更新？"><a href="#为什么setState有异步更新？" class="headerlink" title="为什么setState有异步更新？"></a>为什么setState有异步更新？</h2><p>React在执行setState之后，要执行render、diff、更新DOM等一系列操作，性能开销是比较大的。加入异步更新、更新合并等策略能优化性能。</p>
<h2 id="什么时候异步更新，什么时候同步更新"><a href="#什么时候异步更新，什么时候同步更新" class="headerlink" title="什么时候异步更新，什么时候同步更新"></a>什么时候异步更新，什么时候同步更新</h2><p>组件里等事件处理程序，如 <code>onClick={this.handleClick}</code> 里面等setState是异步更新。声明生命周期函数里等setState也是异步更新。如果需要多次更新需要用异步设置等语法，如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">state, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="attr">count</span>: state.count + props.count &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如setTimeout里，对原生绑定如 addEventListener 里，都是同步更新。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">"#btn"</span>).onclick=<span class="function"><span class="params">()</span>=&gt;</span>&#123;.....setState(...)&#125;</span><br><span class="line">                                                          </span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="keyword">this</span>.setState(...),<span class="keyword">this</span>,setState(...)&#125;,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h2 id="异步更新在效果上有什么表现"><a href="#异步更新在效果上有什么表现" class="headerlink" title="异步更新在效果上有什么表现"></a>异步更新在效果上有什么表现</h2><p>表现为更新合并，上次更新未生效。也就是如果你执行了两次 setState 它只会执行一次，因为它自己做了优化</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/09/react-生命周期等/" data-id="ckb7mn2k0000rzkw1tathuebm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-手写-react" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/06/手写-react/" class="article-date">
  <time datetime="2020-06-06T08:07:31.000Z" itemprop="datePublished">2020-06-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/06/手写-react/">手写 react</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><h6 id="javascript-语法扩展，用于形象描述一段DOM结构"><a href="#javascript-语法扩展，用于形象描述一段DOM结构" class="headerlink" title="javascript 语法扩展，用于形象描述一段DOM结构"></a>javascript 语法扩展，用于形象描述一段DOM结构</h6><p>例如:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">className</span>=<span class="string">"hello"</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      <span class="comment">// 这就是一行 jsx 代码</span></span><br></pre></td></tr></table></figure>
<h6 id="React-推荐使用JSX-但是很明显这么一行JSX-代码是无法在浏览器中运行的。那么我们使用-babel-打包工具来处理我们的代码，babel-会把jsx-转换为-React-createElement-tag-attr-children-那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement-方法，所以为了运行不报错，我们需要定义一个-React-对象，并创建一个-createElement-方法-而babel-帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx-代码一一对应，也就babel把我们页面上的jsx-代码转换为了这三个参数；这三个参数分别是-jsx-代码的-标签（顶级标签）-以及标签上的属性，还有标签里面的内容（一个数组）"><a href="#React-推荐使用JSX-但是很明显这么一行JSX-代码是无法在浏览器中运行的。那么我们使用-babel-打包工具来处理我们的代码，babel-会把jsx-转换为-React-createElement-tag-attr-children-那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement-方法，所以为了运行不报错，我们需要定义一个-React-对象，并创建一个-createElement-方法-而babel-帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx-代码一一对应，也就babel把我们页面上的jsx-代码转换为了这三个参数；这三个参数分别是-jsx-代码的-标签（顶级标签）-以及标签上的属性，还有标签里面的内容（一个数组）" class="headerlink" title="React 推荐使用JSX,但是很明显这么一行JSX 代码是无法在浏览器中运行的。那么我们使用 babel 打包工具来处理我们的代码，babel 会把jsx 转换为 React.createElement(tag,attr,children);那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement 方法，所以为了运行不报错，我们需要定义一个 React 对象，并创建一个 createElement 方法,而babel 帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx 代码一一对应，也就babel把我们页面上的jsx 代码转换为了这三个参数；这三个参数分别是 jsx 代码的 标签（顶级标签）, 以及标签上的属性，还有标签里面的内容（一个数组）;"></a>React 推荐使用JSX,但是很明显这么一行JSX 代码是无法在浏览器中运行的。那么我们使用 babel 打包工具来处理我们的代码，babel 会把jsx 转换为 React.createElement(tag,attr,children);那么显然这样的代码运行也会出错，因为我们并没有定义React对象，更没有createElement 方法，所以为了运行不报错，我们需要定义一个 React 对象，并创建一个 createElement 方法,而babel 帮助我们给这个方法提供了三个参数，这三个参数与页面上的jsx 代码一一对应，也就babel把我们页面上的jsx 代码转换为了这三个参数；这三个参数分别是 jsx 代码的 标签（顶级标签）, 以及标签上的属性，还有标签里面的内容（一个数组）;</h6><h6 id="那我们拿到这三个参数之后，自定义-createElement-方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React-核心就在这块。"><a href="#那我们拿到这三个参数之后，自定义-createElement-方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React-核心就在这块。" class="headerlink" title="那我们拿到这三个参数之后，自定义 createElement 方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React 核心就在这块。"></a>那我们拿到这三个参数之后，自定义 createElement 方法把这三个参数作为一个对象返回。拿到这个对象后，我们是不是就可以通过某些方法来构造标准的html代码了。手写React 核心就在这块。</h6><p> webpack config.js 中配置了 js 或者 jsx文件，会使用 babel 来加载</p>
<p> babel 会把代码转换为 let div = React.createElement(tag,attr,childrenNode)</p>
<p> 如果 createElement 方法不返回，那么 consoel.log(div) 就是 undefined</p>
<p> 所以 我们把 babel 帮我们生成的这个方法的三个参数，这三个参数分别对应我们 html 的 标签，属性，和内容（以及标签嵌套的字标签）</p>
<p> 所以我们把这些内容返回出去，那么 div 就可以接收到这三个参数，做进一步处理</p>
<p> 就变成 let div = { tag,attr,child }</p>
<p>那么很显然如果我们直接打开生成的 index.html 会报错找不到 React,所以，我们需要定义一个 React</p>
<p> webpack config.js 中配置了 js 或者 jsx文件，会使用 babel 来加载</p>
<p> babel 会把代码转换为 let div = React.createElement(tag,attr,childrenNode)</p>
<p> 如果 createElement 方法不返回，那么 consoel.log(div) 就是 undefined</p>
<p> 所以 我们把 babel 帮我们生成的这个方法的三个参数，这三个参数分别对应我们 html 的 标签，属性，和内容（以及标签嵌套的字标签）</p>
<p> 所以我们把这些内容返回出去，那么 div 就可以接收到这三个参数，做进一步处理</p>
<p> 就变成 let div = { tag,attr,child }</p>
<p> 那么很显然如果我们直接打开生成的 index.html 会报错找不到 React,所以，我们需要定义一个 React</p>
<p>现在 这个 div 通过 babel 以及 react.createElment 方法已经成为了一个 携带 tag,attr,children 的对象</p>
<p>那么我们就可以通过这三个对象，将这个div 像html 一样展示在浏览器中</p>
<p>具体就是，我们定义一个方法，把这个div 以及document.body 传递进去，经过处理</p>
<p>拿到 dom 也就是我们这个 div对象后，我们取出里面的 tag</p>
<p>判断dom 的类型,当这个对象没有被标签包裹时，它是一个 string 字符串，可以打印出来看看</p>
<p>如果是字符串，那么直接创建一个 textnode</p>
<p>当有标签包裹时，它是一个 object</p>
<p>处理 属性 传递 节点 和 vdom 上的属性。。。。。。</p>
<p><strong>## 实现自定义标签的渲染</strong></p>
<p> 前面我们通过 babel 已经实现了将 普通的 jsx 转换为 React.createElement(tag,attr,children) </p>
<p> 然后拿到这个生成的虚拟dom,通过定义的 React.render() 方法将tag,attr,children 以标准的 html 的形式展示到了页面上</p>
<p> 那么下一步我们如果想在页面上展示自己定义的标签需要怎么做呢？也就是不是html 内置的这些标签，而是自定义的一些语义化的标签模块</p>
<p> 例如 <app></app> <menue></menue> ……</p>
<p> 根据 babel 的知识，我们知道，它会把这样的标签内容渲染称为 React.createElement(App,attr,children)</p>
<p> 注意这里的 App 不带引号，也就是说它不是一个html 标签，而是一个变量。如果我们直接把它放入页面势必会报错，因为我们没有定义 App</p>
<p> 这个对象，所以我们要定义这个对象 App </p>
<p> 定义好这个对象之后，为了实现内容的渲染，我们可以在 App 对象中定义一个 render() 方法，返回我们要渲染的 html 或者 jsx;</p>
<p> 这样在我们执行 ReactDom.render() 方法时，如果遇到了这样自定义的标签，那么我们就可以 new 一个我们定义好的 APP 对象，然后调用这个对象的 render() 方法 返回一个 html或者 jsx dom,然后我们在解析这个 返回值 不就可以实现了吗</p>
<p> 好了，开始写。。。。。。</p>
<p> 在设置好 state 对象的值后，如果想要有效果需要重新渲染页面，具体就是拿到这个state 所在的组件对象，然后根据新的state 创建新的dom,然后做一下替换即可</p>
<p> 接下来我们要实现一个函数式的组件，也就是es3 的写法的函数 function 组件名,我来重新捋一遍哈,如果是我们自定义的标签而非是 html 标签，babel 会帮助我们转换为 React.createElement(tag,attr,children),这样的形式，那么这个 tag 就是一个变量，而非一个 html 字符串标签，我们需要定义这个 变量对象否则运行就会报错</p>
<p> 前面我们使用es6的方法定义了class 对象，那如果我们使用 es3 function 方法定义呢?那我们上面写的逻辑是获取该组件上的 render() 方法获取我们的 jsx dom,现在改为 function 写法，里面不能再嵌套方法了，只能使用.prototype 的方式添加这个函数，而我们也没有定义这个方法，该如果获取到这个 render 里面的内容呢?</p>
<p> 思路哈： 当我们监测到要渲染的是一个 function 的时候，我们来判断这个对象是一个 function 还是一个 class，根据我们 class 的写法，我们是让这个组件继承了 React.component 这个对象的，那也就意味着 class 对象的 prototype == React.component 对吧, 而 function 方法写的则不会有，所以可以根据这个来判断</p>
<p> 我们可以定义一个处理这个对象的方法，传递这个 tag 标签，返回一个 class 对象(后续逻辑需要)</p>
<p> 那么如果是 class 方式写的，就直接 new 这个对象即可，如果是 function 方法写的，我们需要构造一个render() 方法，并且赋值给一个class，最后 new 这个 class,这样就解决啦,好啦，开写</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/06/手写-react/" data-id="ckb7mn2l20017zkw1u9sx6y54" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-webpack-笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/01/webpack-笔记/" class="article-date">
  <time datetime="2020-06-01T07:25:41.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/01/webpack-笔记/">webpack 笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h6 id="静态模块打包器"><a href="#静态模块打包器" class="headerlink" title="静态模块打包器"></a>静态模块打包器</h6><h6 id="根据文档学习"><a href="#根据文档学习" class="headerlink" title="根据文档学习"></a>根据文档学习</h6><h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h4><h6 id="使用-webpack-命令时，可以指定webpack的配置文件，webpack-–config-webpack-config-js-该命令可以简写为-webpack，它会默认去找这个名称的配置文件"><a href="#使用-webpack-命令时，可以指定webpack的配置文件，webpack-–config-webpack-config-js-该命令可以简写为-webpack，它会默认去找这个名称的配置文件" class="headerlink" title="使用 webpack 命令时，可以指定webpack的配置文件，webpack –config webpack.config.js,该命令可以简写为 webpack，它会默认去找这个名称的配置文件"></a>使用 webpack 命令时，可以指定webpack的配置文件，webpack –config webpack.config.js,该命令可以简写为 webpack，它会默认去找这个名称的配置文件</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">     <span class="string">"build"</span>:<span class="string">"webpack"</span>  </span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p><strong>webpack.config.js 部分内容</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry:<span class="string">'./src/index.js'</span>,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,  <span class="comment">//指定打包后的文件名称,在入口html中引入即可</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>)   <span class="comment">//文件路径</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="有一个概念你必须清楚的就是-我们的项目目录，分为-src-源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。"><a href="#有一个概念你必须清楚的就是-我们的项目目录，分为-src-源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。" class="headerlink" title="有一个概念你必须清楚的就是,我们的项目目录，分为 src 源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。"></a>有一个概念你必须清楚的就是,我们的项目目录，分为 src 源代码目录，供开发人员开发使用，而dist目录是打包后的目录，供上线使用，这个里面的文件经过压缩处理，体积小，而且把我们模块化编写的代码打包成浏览器可以识别的代码。</h6><h4 id="管理输出"><a href="#管理输出" class="headerlink" title="管理输出"></a>管理输出</h4><h6 id="htmlwebpackPlugin-帮助我们生成-dist-下的index-html-也就是最终运行的html-并且将打包后的js文件引入该-html"><a href="#htmlwebpackPlugin-帮助我们生成-dist-下的index-html-也就是最终运行的html-并且将打包后的js文件引入该-html" class="headerlink" title="htmlwebpackPlugin 帮助我们生成 dist 下的index.html,(也就是最终运行的html)并且将打包后的js文件引入该 html."></a>htmlwebpackPlugin 帮助我们生成 dist 下的index.html,(也就是最终运行的html)并且将打包后的js文件引入该 html.</h6><h4 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h4><p><strong>inline-source-map</strong></p>
<h6 id="webpack-config-js-中-配置-dev-tool-inline-source-map-作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员"><a href="#webpack-config-js-中-配置-dev-tool-inline-source-map-作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员" class="headerlink" title="webpack.config.js 中 配置 dev-tool:inline-source-map,作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员"></a>webpack.config.js 中 配置 dev-tool:inline-source-map,作用是对源码和打包后的代码做一个映射，这样出错后，点击相应的文件能定位到源代码，方便开发人员</h6><hr>
<h4 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h4><h6 id="刚发现-webpack-dev-server-执行后并不会在本地生成-dist-文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server-，而在生产环境，我们直接执行-npx-webpack-打包好代码，这个命令会在当前目录生成-dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。"><a href="#刚发现-webpack-dev-server-执行后并不会在本地生成-dist-文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server-，而在生产环境，我们直接执行-npx-webpack-打包好代码，这个命令会在当前目录生成-dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。" class="headerlink" title="刚发现 webpack-dev-server 执行后并不会在本地生成 dist 文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server ，而在生产环境，我们直接执行 npx webpack 打包好代码，这个命令会在当前目录生成 dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。"></a>刚发现 webpack-dev-server 执行后并不会在本地生成 dist 文件夹，以及打包后的文件，在浏览器中可以看到打包后的js，再一次明确一点哈：开发环境我们为了方便查看页面的变化所以引入了webpack-dev-server ，而在生产环境，我们直接执行 npx webpack 打包好代码，这个命令会在当前目录生成 dist文件夹，文件夹下是相应的打包文件，然后把这个dist放入服务器即可。</h6><p>刚刚使用 webpack-dev-server 纳闷了半天 dist 为何是空的</p>
<p>也就是说：我们引入 htmlwebpackplugin 插件 这个插件会生成dist文件夹，并且在里面生成 index.html,并且引入相关打包后的js,以及我们引入的 cleanwebpackplugin 插件，清理 dist文件夹，都是为了我们的生产环境而引入的。我这样理解没错吧，可为何，安装包时放到了 dev中，为了开发测试？</p>
<h4 id="HMR-（hot-module-replacement）-模块热更新）（仅限开发环境使用）"><a href="#HMR-（hot-module-replacement）-模块热更新）（仅限开发环境使用）" class="headerlink" title="HMR （hot module replacement） 模块热更新）（仅限开发环境使用）"></a>HMR （hot module replacement） 模块热更新）（仅限开发环境使用）</h4><p>它允许在运行时更新各种模块，而无需进行完全刷新，即只变动你修改的地方，其他的代码还保留之前的状态。</p>
<p>启用这个功能需要配合 webpack-dev-server 一起使用。</p>
<h6 id="使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码："><a href="#使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码：" class="headerlink" title="使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码："></a>使用这个功能的时候，如果想要对某一个模块进行热更新，需要在入口文件中加入一些代码：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在要热更细的模块中</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;  <span class="comment">//判断是否开启了热更新</span></span><br><span class="line"><span class="comment">//热更新功能接受print.js的变动的更新,即只刷新print.js 中的变动，其他代码状态不会被刷新</span></span><br><span class="line"><span class="comment">// 例如，入口文件中有一个变量i,每次执行都会++，你会发现当接受print.js的热更新后，入口文件中的 i还是会从它上次执行的地方开始++，而不是从初始值（例如1）开始；这就是热更新</span></span><br><span class="line">	<span class="built_in">module</span>.hot.accept(<span class="string">'./print.js'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="comment">//回调函数</span></span><br><span class="line">		</span><br><span class="line">	&#125;),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Tree-shaking"><a href="#Tree-shaking" class="headerlink" title="Tree shaking"></a>Tree shaking</h4><h6 id="你可以将应用程序想象成一棵树。绿色表示实际用到的源码和-library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。"><a href="#你可以将应用程序想象成一棵树。绿色表示实际用到的源码和-library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。" class="headerlink" title="你可以将应用程序想象成一棵树。绿色表示实际用到的源码和 library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。"></a>你可以将应用程序想象成一棵树。绿色表示实际用到的源码和 library，是树上活的树叶。灰色表示无用的代码，是秋天树上枯萎的树叶。为了除去死去的树叶，你必须摇动这棵树，使它们落下。</h6><p>结论： 在生产环境下，加入  mode: “production” 就会自动将无用的代码给去除，减小体积，提高效率</p>
<p>例如，在a.js 中有export 出了两个函数，但只被引用了一个函数，但打包后，你会发现打包后的代码中依旧是包含未使用的函数的，加入这个配置后，就会只引入使用的这个函数；binggo</p>
<h4 id="生产环境"><a href="#生产环境" class="headerlink" title="生产环境"></a>生产环境</h4><h6 id="开发环境-development-和生产环境-production-的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载-live-reloading-或热模块替换-hot-module-replacement-能力的-source-map-和-localhost-server。而在生产环境中，我们的目标则转向于关注更小的-bundle，更轻量的-source-map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的-webpack-配置"><a href="#开发环境-development-和生产环境-production-的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载-live-reloading-或热模块替换-hot-module-replacement-能力的-source-map-和-localhost-server。而在生产环境中，我们的目标则转向于关注更小的-bundle，更轻量的-source-map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的-webpack-配置" class="headerlink" title="开发环境(development)和生产环境(production)的构建目标差异很大。在开发环境中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在生产环境中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置"></a><em>开发环境(development)</em>和<em>生产环境(production)</em>的构建目标差异很大。在<em>开发环境</em>中，我们需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server。而在<em>生产环境</em>中，我们的目标则转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间。由于要遵循逻辑分离，我们通常建议为每个环境编写<strong>彼此独立的 webpack 配置</strong></h6><p>使用参考官方文档</p>
<p>思路：拆分 webpack.config.js</p>
<p>开发环境：webpack-dev.js</p>
<p>生产环境： webpack-prod.js</p>
<p>common.js ：包含生产和开发环境都需要的公共的一些配置</p>
<p>下载一个 merge 包，用来根据不同的环境  —- 开发环境（或者生产环境）的js 和 common.js 合并</p>
<p>在package.js scripts 中设置脚本，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如</span></span><br><span class="line">scripts:&#123;</span><br><span class="line">    <span class="string">"start"</span>:<span class="string">"webpack-dev-server --open --config webpack.dev.js"</span> , <span class="comment">//启动 webpackserver 并且是通过开发环境的配置文件启动的</span></span><br><span class="line">    <span class="string">"build"</span>:<span class="string">"webpack --config webpack.prod.js"</span>  <span class="comment">//生产环境的配置文件，生产环境是不需要启动webpackserver的，所以就是这样喽</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指定环境"><a href="#指定环境" class="headerlink" title="指定环境"></a>指定环境</h4><p>任何位于 <code>/src</code> 的本地代码都可以关联到 process.env.NODE_ENV 环境变量，所以以下检查也是有效的</p>
<p>配置环境的步骤如下：</p>
<p>在相应的webpack配置文件中写上，例如在dev.js 中写 development</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">            <span class="string">'process.env.NODE_ENV'</span>:<span class="built_in">JSON</span>.stringify(<span class="string">'development'</span>)</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<p>这样，你执行 该文件的话，就会获得当前配置的环境名称，然后做判断，例如打印日志什么的</p>
<p>在 src下的文件中都可以访问到该 类似全局变量的这个环境配置</p>
<h4 id="代码分离-好处就是可以把共有的东西抽离出来"><a href="#代码分离-好处就是可以把共有的东西抽离出来" class="headerlink" title="代码分离 好处就是可以把共有的东西抽离出来"></a>代码分离 好处就是可以把共有的东西抽离出来</h4><h6 id="代码分离就是可以把不同的文件打包到不同的bundle-js中，例如之前配置的-多个-entry-以及output"><a href="#代码分离就是可以把不同的文件打包到不同的bundle-js中，例如之前配置的-多个-entry-以及output" class="headerlink" title="代码分离就是可以把不同的文件打包到不同的bundle.js中，例如之前配置的 多个 entry,以及output"></a>代码分离就是可以把不同的文件打包到不同的bundle.js中，例如之前配置的 多个 entry,以及output</h6><p>如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中</p>
<p>但这种方式需要我们手动配置太麻烦，而且还会有一个问题，例如这两个入口文件中都引用了jquery,那么最终生成的两个 bundle.js 中都会包含 jquery,这样无疑文件体积会大很多，怎么解决呢，就是把共有的juqery 提取出来，其他模块需要，引入即可。</p>
<p>具体解决方案：CommonsChunkPlugin</p>
<p>这个插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk</p>
<p>使用步骤见官网文档</p>
<p><strong>动态导入</strong></p>
<h6 id="就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入"><a href="#就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入" class="headerlink" title="就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入"></a>就是在使用到它的时候在引入，例如有一个功能组件需要我们登陆后操作，那么我们在登录之前可以不用加载该模块，等用到的时候再导入</h6><p>这时候，我们不用指定多个入口，配置好后，通过动态引入这个公用的库，它会自动生成一个公用的js</p>
<p>使用 import 函数 promise 风格的函数</p>
<p>参见官网</p>
<h4 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h4><p><strong>webpack 为何需要多个入口文件和输出文件？</strong></p>
<h6 id="答：项目中肯定不止一个html页面，a页面需要引入a-js，b-js，c-js-在入口文件中require-a页面需要的js文件即可。"><a href="#答：项目中肯定不止一个html页面，a页面需要引入a-js，b-js，c-js-在入口文件中require-a页面需要的js文件即可。" class="headerlink" title="答：项目中肯定不止一个html页面，a页面需要引入a.js，b.js，c.js 在入口文件中require a页面需要的js文件即可。"></a>答：项目中肯定不止一个html页面，a页面需要引入a.js，b.js，c.js 在入口文件中require a页面需要的js文件即可。</h6><h6 id="b页面需要引入d-js-，e-js-，f-js-，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？"><a href="#b页面需要引入d-js-，e-js-，f-js-，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？" class="headerlink" title="b页面需要引入d.js ，e.js ，f.js ，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？"></a>b页面需要引入d.js ，e.js ，f.js ，如果不能设置多个入口文件和多个编译输出文件的话就需要在入口文件中引入全部6个js文件，并编译到一个输出文件，这岂不是违背了模块管理工具的初衷呢？</h6><h6 id="这就像是不同的模块需要不同的js一样"><a href="#这就像是不同的模块需要不同的js一样" class="headerlink" title="这就像是不同的模块需要不同的js一样"></a>这就像是不同的模块需要不同的js一样</h6><h4 id="自己创建-loader"><a href="#自己创建-loader" class="headerlink" title="自己创建 loader"></a>自己创建 loader</h4><h6 id="自己手写一个loader-需要在-webpack配置文件中指定loader的路径，有需要可以配置一些-options"><a href="#自己手写一个loader-需要在-webpack配置文件中指定loader的路径，有需要可以配置一些-options" class="headerlink" title="自己手写一个loader,需要在 webpack配置文件中指定loader的路径，有需要可以配置一些 options"></a>自己手写一个loader,需要在 webpack配置文件中指定loader的路径，有需要可以配置一些 options</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//指定loader 目录</span></span><br><span class="line">    resolveLoader: &#123;</span><br><span class="line">        modules: [</span><br><span class="line">            <span class="string">'node_mdules'</span>,</span><br><span class="line">            path.resolve(__dirname, <span class="string">'loaders'</span>)</span><br><span class="line">        ]</span><br><span class="line">    &#125;, </span><br><span class="line"></span><br><span class="line">--------------------------------------------------------------</span><br><span class="line">&#123;</span><br><span class="line">                test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">                use:[</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//如果不在上面统一指明 loaders目录，那么就要像下面这样写全路径</span></span><br><span class="line">                        <span class="comment">// loader:path.resolve(__dirname,'loaders/replace.js'),</span></span><br><span class="line">                        <span class="comment">//如果已经制定了loader的目录那么这里loader直接写</span></span><br><span class="line">                        loader:<span class="string">"replace"</span>,</span><br><span class="line">                        options:&#123;</span><br><span class="line">                            name:<span class="string">'abc'</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<h6 id="loader-的编写"><a href="#loader-的编写" class="headerlink" title="loader 的编写"></a>loader 的编写</h6><h6 id="所谓-loader-只是一个导出为函数的-JavaScript-模块，（官网介绍的特别详细）loader-runner-会调用这个函数，然后把上一个-loader-产生的结果或者资源文件-resource-file-传入进去。函数的-this-上下文将由-webpack-填充，并且-loader-runner-具有一些有用方法，可以使-loader-改变为异步调用方式，或者获取-query-参数。"><a href="#所谓-loader-只是一个导出为函数的-JavaScript-模块，（官网介绍的特别详细）loader-runner-会调用这个函数，然后把上一个-loader-产生的结果或者资源文件-resource-file-传入进去。函数的-this-上下文将由-webpack-填充，并且-loader-runner-具有一些有用方法，可以使-loader-改变为异步调用方式，或者获取-query-参数。" class="headerlink" title="所谓 loader 只是一个导出为函数的 JavaScript 模块，（官网介绍的特别详细）loader runner 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 this 上下文将由 webpack 填充，并且 loader runner 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。"></a>所谓 loader 只是一个导出为函数的 JavaScript 模块，（官网介绍的特别详细）<a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">loader runner</a> 会调用这个函数，然后把上一个 loader 产生的结果或者资源文件(resource file)传入进去。函数的 <code>this</code> 上下文将由 webpack 填充，并且 <a href="https://github.com/webpack/loader-runner" target="_blank" rel="noopener">loader runner</a> 具有一些有用方法，可以使 loader 改变为异步调用方式，或者获取 query 参数。</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// testLoader.js</span></span><br><span class="line"><span class="keyword">const</span> &#123; getOptions &#125; = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">source,map,meta</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//source 就是我们在配置文件中，设置匹配正则表达式的文件，而在loader 中 我们要做的事情就是，通过我们自己的一些个性化处理，来处理这个 source,然后返回出去</span></span><br><span class="line">    doSomeThing(csource)</span><br><span class="line">    <span class="keyword">const</span> options = getOptions(<span class="keyword">this</span>)</span><br><span class="line">    <span class="comment">// options 就是webpackconfig.js中loader配置的 options 参数</span></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自己创建-plugin"><a href="#自己创建-plugin" class="headerlink" title="自己创建 plugin"></a>自己创建 plugin</h4><h6 id="插件能够-钩入-hook-到在每个编译-compilation-中触发的所有关键事件。在编译的每一步，插件都具备完全访问-compiler-对象的能力，如果情况合适，还可以访问当前-compilation-对象。"><a href="#插件能够-钩入-hook-到在每个编译-compilation-中触发的所有关键事件。在编译的每一步，插件都具备完全访问-compiler-对象的能力，如果情况合适，还可以访问当前-compilation-对象。" class="headerlink" title="插件能够 钩入(hook) 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 compiler 对象的能力，如果情况合适，还可以访问当前 compilation 对象。"></a>插件能够 <a href="https://www.webpackjs.com/api/compiler-hooks/#hooks" target="_blank" rel="noopener">钩入(hook)</a> 到在每个编译(compilation)中触发的所有关键事件。在编译的每一步，插件都具备完全访问 <code>compiler</code> 对象的能力，如果情况合适，还可以访问当前 <code>compilation</code> 对象。</h6><p>就是在编译过程的某个阶段做一些特定的事情</p>
<p><code>webpack</code> 插件由以下组成：</p>
<ul>
<li>一个 JavaScript 命名函数</li>
<li>在插件函数的 prototype 上定义一个 <code>apply</code> 方法。</li>
<li>指定一个绑定到 webpack 自身的<a href="https://www.webpackjs.com/api/compiler-hooks/" target="_blank" rel="noopener">事件钩子</a></li>
<li>处理 webpack 内部实例的特定数据</li>
<li>功能完成后调用 webpack 提供的回调。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本构架  es3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloPlugin</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//compiler 对象是webpack 创建的一个对象，可以访问到webpack构建的每个过程,</span></span><br><span class="line">HelloPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//compiler 在执行过程中，可以获得当前过程中的 编译过程对象 compilation</span></span><br><span class="line">    compiler.hooks.done.tap(<span class="string">'helloPlugin'</span>,compilation=&gt;&#123;</span><br><span class="line">        <span class="comment">//做一些事情</span></span><br><span class="line">        consoel.log(<span class="string">'do something here'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = HelloPlugin</span><br><span class="line">-----------------------------------------</span><br><span class="line"><span class="comment">//es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloPlugin</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options)&#123;</span><br><span class="line">        <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line">    apply(compiler)&#123;</span><br><span class="line">         compiler.hooks.done.tap(<span class="string">'helloPlugin'</span>,compilation=&gt;&#123;</span><br><span class="line">        consoel.log(<span class="string">'do something here'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = HelloPlugin</span><br></pre></td></tr></table></figure>
<p><strong>哎，具体，我们也没学明白，就知道，先这样用起来</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/01/webpack-笔记/" data-id="ckb7mn2k6000wzkw1yjl5dntj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/webpack/">webpack</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-node-js-commonJs规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/01/node-js-commonJs规范/" class="article-date">
  <time datetime="2020-06-01T03:28:42.000Z" itemprop="datePublished">2020-06-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/01/node-js-commonJs规范/">node.js commonJs规范</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>基于 Chrome V8 引擎的 javascript 运行环境。</p>
<p>可用于开发网站后台，开发本地工具，应用，特点是：事件驱动，非阻塞式IO模型，强大的生态NPM</p>
<h4 id="服务器端概念"><a href="#服务器端概念" class="headerlink" title="服务器端概念"></a>服务器端概念</h4><p><strong>计算密集型  最好用 C C++ 来实现</strong></p>
<h6 id="大量的计算，小号CPU-资源，例如对视频进行解码，加密解密操作"><a href="#大量的计算，小号CPU-资源，例如对视频进行解码，加密解密操作" class="headerlink" title="大量的计算，小号CPU 资源，例如对视频进行解码，加密解密操作"></a>大量的计算，小号CPU 资源，例如对视频进行解码，加密解密操作</h6><p><strong>IO密集型 node.js 适合 io密集型应用</strong>  </p>
<h6 id="网络、磁盘读写频繁，例如上传下载等功能，包括读写数据库"><a href="#网络、磁盘读写频繁，例如上传下载等功能，包括读写数据库" class="headerlink" title="网络、磁盘读写频繁，例如上传下载等功能，包括读写数据库"></a>网络、磁盘读写频繁，例如上传下载等功能，包括读写数据库</h6><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><h6 id="登录-nodejs-官网下载安装"><a href="#登录-nodejs-官网下载安装" class="headerlink" title="登录 nodejs 官网下载安装"></a>登录 nodejs 官网下载安装</h6><p><strong>使用node.js 内置模块</strong>  </p>
<h6 id="node-js-内置了许多处理模块，例如文件处理模块-filesystem-路径处理模块path，http模块等"><a href="#node-js-内置了许多处理模块，例如文件处理模块-filesystem-路径处理模块path，http模块等" class="headerlink" title="node.js 内置了许多处理模块，例如文件处理模块 filesystem,路径处理模块path，http模块等"></a>node.js 内置了许多处理模块，例如文件处理模块 filesystem,路径处理模块path，http模块等</h6><p>使用如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 require 关键字引入 文件处理模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'path'</span>,<span class="string">'编码'</span>，callback(err,str)&#123;&#125;)</span><br><span class="line"><span class="comment">//具体使用查看 api</span></span><br></pre></td></tr></table></figure>
<p><strong>使用本地模块</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 util.js 后缀可以省略</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'./util'</span>)</span><br><span class="line">使用： util.fact(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//util.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fact</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(n===<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span>  n*fact(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用第三方模块</strong></p>
<p>node.js 有强大的生态系统 npm，上面有许多开发者上传的自己写的各种工具包，如果我们有需要可以从上面下载下来，作为第三方的模块来使用</p>
<h6 id="npm-install-模块"><a href="#npm-install-模块" class="headerlink" title="npm install 模块"></a>npm install 模块</h6><h4 id="CommonJs-规范"><a href="#CommonJs-规范" class="headerlink" title="CommonJs 规范"></a>CommonJs 规范</h4><h6 id="一个文件是一个模块"><a href="#一个文件是一个模块" class="headerlink" title="一个文件是一个模块"></a>一个文件是一个模块</h6><pre><code>文件中变量、函数、类都是私有的
</code></pre><h6 id="每个模块内部，module-代表当前模块"><a href="#每个模块内部，module-代表当前模块" class="headerlink" title="每个模块内部，module 代表当前模块"></a>每个模块内部，module 代表当前模块</h6><p>​         module.exports 是对外的接口。加载某个模块，其实是加载该模块的 module.exports</p>
<h6 id="注意-module-exports-与直接使⽤-exports的差异"><a href="#注意-module-exports-与直接使⽤-exports的差异" class="headerlink" title="注意 module.exports 与直接使⽤ exports的差异"></a>注意 module.exports 与直接使⽤ exports的差异</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//a.js</span></span><br><span class="line"> <span class="keyword">let</span> num =<span class="number">1</span></span><br><span class="line"> <span class="keyword">const</span> add = <span class="function"><span class="params">()</span>=&gt;</span>++num</span><br><span class="line"> <span class="built_in">module</span>.exports.num = num</span><br><span class="line"> <span class="built_in">module</span>.exports.add = add   <span class="built_in">module</span>.exports 可以把它当成一个对象</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//b.js</span></span><br><span class="line"> <span class="keyword">let</span> obj = <span class="built_in">require</span>(<span class="string">'./a.js'</span>)  <span class="comment">//obj 对象就是你export 出来的 module.exports</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj.num)  <span class="comment">// 普通变量</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.add())  <span class="comment">//函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//module.exports 也可以这样用</span></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sum:<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [...arguments].reduce(<span class="function">(<span class="params">v1,v2</span>)=&gt;</span>v1+v2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入使用也是一样的,记住你 export 出来的是什么引入的就是什么,module.exports 就是module 的一个属性</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="built_in">require</span>(<span class="string">'./test.js'</span>)</span><br><span class="line">m.sum(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">//补充例子  n.js	</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    sum:<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [...arguments].reduce(<span class="function">(<span class="params">v1,v2</span>)=&gt;</span> v1+v2)</span><br><span class="line">    &#125;,</span><br><span class="line">    name:<span class="string">'zhangsan'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">const</span> m = <span class="built_in">require</span>(<span class="string">'./n.js'</span>)</span><br><span class="line">n.sum(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">n.name</span><br></pre></td></tr></table></figure>
<h4 id="exports-与-module-exports的区别"><a href="#exports-与-module-exports的区别" class="headerlink" title="exports 与 module.exports的区别"></a>exports 与 module.exports的区别</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//c.js</span></span><br><span class="line"><span class="comment">// 你可以理解为有这么一句话  exports = module.exports</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [...arguments].reduce(<span class="function">(<span class="params">v1,v2</span>)=&gt;</span> v1+v2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = sum  <span class="comment">//正确</span></span><br><span class="line"><span class="comment">// exports = sum   错误的写法</span></span><br><span class="line"><span class="comment">// exports.sum = sum 正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//d.js</span></span><br><span class="line"><span class="keyword">const</span> sum = <span class="built_in">require</span>(<span class="string">'./c'</span>)  <span class="comment">//名称可以随意取</span></span><br><span class="line">consoel.log(sum(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>
<h4 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h4><p>• npm init   在当前目录下，初始化一个package.json  npm init -y 按照默认生成</p>
<p>• npm install </p>
<p>​    ✓ npm install -g http-server    全局安装 http-server</p>
<p>​    ✓ npm install –save axios        将依赖保存在package.json 中的dependency中</p>
<p>​     ✓ npm install -S axios                 同上</p>
<p>​    ✓ npm install –save-dev webpack     将依赖保存在 devdependency中</p>
<p>​    ✓ npm install -D webpack   </p>
<p>​    ✓ npm install </p>
<p>• npm uninstall  </p>
<p>• npm start</p>
<p> • npm run </p>
<p> • npm config –help </p>
<p>• npm login </p>
<p>• npm publish</p>
<p>• npx <commond>    安装的第三方工具，需要在命令行中执行时，需要使用npx</commond></p>
<h6 id="npx-想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具-Mocha"><a href="#npx-想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具-Mocha" class="headerlink" title="npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 Mocha"></a>npx 想要解决的主要问题，就是调用项目内部安装的模块。比如，项目内部安装了测试工具 <a href="http://www.ruanyifeng.com/blog/2015/12/a-mocha-tutorial-of-examples.html" target="_blank" rel="noopener">Mocha</a></h6><p>一般来说，调用 Mocha ，只能在项目脚本和 package.json 的<a href="http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html" target="_blank" rel="noopener"><code>scripts</code></a>字段里面， 如果想在命令行下调用，必须像下面这样。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目的根目录下执行</span></span><br><span class="line">$ node-modules/.bin/mocha --version</span><br></pre></td></tr></table></figure>
<p>npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx mocha --version</span><br></pre></td></tr></table></figure>
<p>npx 的原理很简单，就是运行的时候，会到<code>node_modules/.bin</code>路径和环境变量<code>$PATH</code>里面，检查命令是否存在。</p>
<p>由于 npx 会检查环境变量<code>$PATH</code>，所以系统命令也可以调用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等同于 ls</span></span><br><span class="line">$ npx ls</span><br></pre></td></tr></table></figure>
<p>参考 阮一峰的网络日志</p>
<h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><h6 id="yarn-也是一个包管理器，起初是为了解决npm下载速度慢的情况，但现在可以直接使用npm"><a href="#yarn-也是一个包管理器，起初是为了解决npm下载速度慢的情况，但现在可以直接使用npm" class="headerlink" title="yarn 也是一个包管理器，起初是为了解决npm下载速度慢的情况，但现在可以直接使用npm"></a>yarn 也是一个包管理器，起初是为了解决npm下载速度慢的情况，但现在可以直接使用npm</h6>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/01/node-js-commonJs规范/" data-id="ckb7mn2jv000pzkw1bkhvsxoq" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端模块化、工程化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/31/前端模块化、工程化/" class="article-date">
  <time datetime="2020-05-31T12:02:37.000Z" itemprop="datePublished">2020-05-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/31/前端模块化、工程化/">前端模块化、工程化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><p><em>实现模块化的原始方法</em></p>
<h6 id="模块化就是同一功能的代码放在一个模块中，应用需要这个功能，引入即可"><a href="#模块化就是同一功能的代码放在一个模块中，应用需要这个功能，引入即可" class="headerlink" title="模块化就是同一功能的代码放在一个模块中，应用需要这个功能，引入即可"></a>模块化就是同一功能的代码放在一个模块中，应用需要这个功能，引入即可</h6><p><strong>优点</strong></p>
<ol>
<li>解决包的依赖管理</li>
<li>命名冲突</li>
<li>代码可读性</li>
<li>代码复用性</li>
</ol>
<h6 id="把代码放在一个对象内，看起来更聚合"><a href="#把代码放在一个对象内，看起来更聚合" class="headerlink" title="把代码放在一个对象内，看起来更聚合"></a>把代码放在一个对象内，看起来更聚合</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">    init()&#123;</span><br><span class="line">        <span class="keyword">this</span>.bind()</span><br><span class="line">    &#125;,</span><br><span class="line">    bind()&#123;&#125;,</span><br><span class="line">    render()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.init()</span><br></pre></td></tr></table></figure>
<h6 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">let</span> $btn = <span class="built_in">document</span>.querySelector(<span class="string">'.btn'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> bind()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> $btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"> render()</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'render'</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> &#123; init &#125;</span><br><span class="line"> &#125;)()</span><br><span class="line"> app.init()</span><br></pre></td></tr></table></figure>
<p><strong>CommonJS 规范</strong></p>
<h6 id="使用-require-方法，在需要某个模块的时候把它到处，在需要的地方引入即可，但浏览器本身是不能识别该关键字的，所以我们需要一些打包工具，帮助我们把代码打包成浏览器可以识别的文件"><a href="#使用-require-方法，在需要某个模块的时候把它到处，在需要的地方引入即可，但浏览器本身是不能识别该关键字的，所以我们需要一些打包工具，帮助我们把代码打包成浏览器可以识别的文件" class="headerlink" title="使用 require 方法，在需要某个模块的时候把它到处，在需要的地方引入即可，但浏览器本身是不能识别该关键字的，所以我们需要一些打包工具，帮助我们把代码打包成浏览器可以识别的文件"></a>使用 require 方法，在需要某个模块的时候把它到处，在需要的地方引入即可，但浏览器本身是不能识别该关键字的，所以我们需要一些打包工具，帮助我们把代码打包成浏览器可以识别的文件</h6><p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//test.js</span><br><span class="line">function sum()&#123;</span><br><span class="line">	return &apos;test&apos;</span><br><span class="line">&#125;</span><br><span class="line">module.exports.sum = sum</span><br><span class="line"></span><br><span class="line">//index.js  引入</span><br><span class="line">const &#123;test&#125; = require(&apos;./test&apos;)</span><br><span class="line">//使用  此时 test就是引入的一个sum 函数</span><br><span class="line">test()</span><br></pre></td></tr></table></figure>
<!--showmore-->
<p><strong>Parcel.js</strong>   (官网查看它的详细用法)</p>
<h4 id="ES6-的模块-Module-概念"><a href="#ES6-的模块-Module-概念" class="headerlink" title="ES6 的模块 Module 概念"></a>ES6 的模块 Module 概念</h4><h6 id="与-commonjs-不同，es6-导出与引入使用关键字-import-export"><a href="#与-commonjs-不同，es6-导出与引入使用关键字-import-export" class="headerlink" title="与 commonjs 不同，es6 导出与引入使用关键字 import,export"></a>与 commonjs 不同，es6 导出与引入使用关键字 import,export</h6><p>导出</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.js</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'test'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;name,sayName,Toast&#125;  <span class="comment">//导出三个对象 分别是普通变量，函数，和类对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//main.js 引入,引入时注意 变量名要与导出的一致，否则会找不到</span></span><br><span class="line"><span class="keyword">import</span> &#123;name,sayName,Toast&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="built_in">console</span>.log(name)</span><br><span class="line">sayName()</span><br><span class="line"><span class="keyword">new</span> Toast()</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">//导出默认</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toast</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Toast</span><br><span class="line"></span><br><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> myToast(名字随意取) <span class="keyword">from</span> <span class="string">'./main.js'</span>  <span class="comment">//仅限于默认导出，名字可以随意取</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> myToast</span><br><span class="line">-----------------------------------------------------------------------------------------</span><br><span class="line">    <span class="comment">//多次使用 export 导出</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">let</span> nem = <span class="string">'test'</span>  <span class="comment">//导出变量</span></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;&#125;  <span class="comment">//导出函数</span></span><br><span class="line">	<span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Toast</span></span>&#123;&#125;  <span class="comment">//导出类</span></span><br><span class="line">	<span class="comment">//注意多次导出要把变量或者函数的声明一起导出才可以</span></span><br><span class="line"><span class="comment">//不可以这样写</span></span><br><span class="line"><span class="keyword">let</span> name = <span class="string">'test'</span></span><br><span class="line"><span class="keyword">export</span> name; <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">export</span> &#123;name&#125; <span class="comment">//正确    日常使用一定要注意</span></span><br></pre></td></tr></table></figure>
<h4 id="ES6-import-与-commonjs-require-区别"><a href="#ES6-import-与-commonjs-require-区别" class="headerlink" title="ES6 import 与 commonjs require 区别"></a>ES6 import 与 commonjs require 区别</h4><h6 id="ES6-import-是静态解析-值的拷⻉"><a href="#ES6-import-是静态解析-值的拷⻉" class="headerlink" title="ES6 import 是静态解析  值的拷⻉"></a>ES6 import 是静态解析  值的拷⻉</h6><h6 id="CommonJS-require-运⾏时加载-值的引用"><a href="#CommonJS-require-运⾏时加载-值的引用" class="headerlink" title="CommonJS require 运⾏时加载 值的引用"></a>CommonJS require 运⾏时加载 值的引用</h6><p>详情参见 阮一峰ES6教程</p>
<h4 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h4><h6 id="要想在Node-js中使⽤ES6-Module"><a href="#要想在Node-js中使⽤ES6-Module" class="headerlink" title="要想在Node.js中使⽤ES6 Module"></a>要想在Node.js中使⽤ES6 Module</h6><p>版本 &gt; v13.2 ， 在package.json⾥加 {“type”: “module” } 即可支持使用 import</p>
<h6 id="浏览器中使用-ES6Module"><a href="#浏览器中使用-ES6Module" class="headerlink" title="浏览器中使用 ES6Module"></a>浏览器中使用 ES6Module</h6><p><script type="module" src="./main.js"><br>    特性新，IE和部分⼿机浏览器不兼容<br>    ⽬前使⽤打包器：Webapck、Rollup、Parcel，配合Babel将 es6语法转换为 es5<br><strong>当然，在打包工具的帮助下我们也可以使用 es6 的 module</strong></p>
<h4 id="⼯程化"><a href="#⼯程化" class="headerlink" title="⼯程化"></a>⼯程化</h4><h6 id="NPM-Scripts-实现⼯程化"><a href="#NPM-Scripts-实现⼯程化" class="headerlink" title="NPM Scripts 实现⼯程化"></a>NPM Scripts 实现⼯程化</h6><p>package.json 文件中的 scripts 模块中的指令可以通过  npm run 命令，来执行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line"> <span class="string">"start"</span>: <span class="string">"parcel index.html"</span>,</span><br><span class="line"> <span class="string">"dev"</span>: <span class="string">"parcel index.html"</span>,</span><br><span class="line"> <span class="string">"build"</span>: <span class="string">"rm -rf dist &amp;&amp; parcel build index.html"</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">npm start   执行  parcel index.html</span><br><span class="line">npm run dev   ....</span><br><span class="line">npm run build ......</span><br></pre></td></tr></table></figure>
<h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><h6 id="JS-组件化-new-一个对象，例如-dialog组件"><a href="#JS-组件化-new-一个对象，例如-dialog组件" class="headerlink" title="JS 组件化  new 一个对象，例如 dialog组件"></a>JS 组件化  new 一个对象，例如 dialog组件</h6><h6 id="资源组件化"><a href="#资源组件化" class="headerlink" title="资源组件化"></a>资源组件化</h6><p>每个组件包含模板、样式、逻辑，是功能完备 的结构单元</p>
<h4 id="重构项目"><a href="#重构项目" class="headerlink" title="重构项目"></a>重构项目</h4><h4 id="一般来说，项目结构如下"><a href="#一般来说，项目结构如下" class="headerlink" title="一般来说，项目结构如下"></a>一般来说，项目结构如下</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line"> |-- pages <span class="comment">//多个⻚⾯</span></span><br><span class="line">     |-- index <span class="comment">//⾸⻚</span></span><br><span class="line">         |-- index.html</span><br><span class="line">         |-- main.css <span class="comment">//当前⻚⾯的样式</span></span><br><span class="line">         |-- main.js <span class="comment">//当前⻚⾯的功能</span></span><br><span class="line"> |-- components <span class="comment">//组件</span></span><br><span class="line">     |-- toast</span><br><span class="line">         |-- main.css</span><br><span class="line">         |-- main.js</span><br><span class="line"> |-- <span class="keyword">static</span> <span class="comment">//静态资源，主要是图⽚</span></span><br><span class="line"> 	|-- logo.png</span><br><span class="line"> |-- stylesheets <span class="comment">//基础样式或者公共样式</span></span><br><span class="line"> 	|-- base.css</span><br><span class="line"> |-- utils <span class="comment">//通⽤的库函数</span></span><br><span class="line">	 |-- util.js</span><br><span class="line"> |-- fonts <span class="comment">//字体或者字体图标</span></span><br></pre></td></tr></table></figure>
<h4 id="打包工具"><a href="#打包工具" class="headerlink" title="打包工具"></a>打包工具</h4><h6 id="模块打包器，将我们使用模块化（commonjs-es6）方式写的源码（本身浏览器是不支持的比如说-require-import）经过打包，变成可以直接使用的代码-其中包括压缩合并，例如-parcel-webpack"><a href="#模块打包器，将我们使用模块化（commonjs-es6）方式写的源码（本身浏览器是不支持的比如说-require-import）经过打包，变成可以直接使用的代码-其中包括压缩合并，例如-parcel-webpack" class="headerlink" title="模块打包器，将我们使用模块化（commonjs es6）方式写的源码（本身浏览器是不支持的比如说 require import）经过打包，变成可以直接使用的代码,其中包括压缩合并，例如 parcel,webpack."></a>模块打包器，将我们使用模块化（commonjs es6）方式写的源码（本身浏览器是不支持的比如说 require import）经过打包，变成可以直接使用的代码,其中包括压缩合并，例如 parcel,webpack.</h6><p><strong>一个软件用起来越简单，它的封装程度越高，例如parcel，很难做个性化的处理，所以下面我们学习webpack 一个功能更强大的模块打包器</strong></p>
</script></p>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/31/前端模块化、工程化/" data-id="ckb7mn2ky0014zkw185cya04v" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工程化/">工程化</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/22/跨域/" class="article-date">
  <time datetime="2020-05-22T03:11:18.000Z" itemprop="datePublished">2020-05-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/22/跨域/">跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="跨域同源策略"><a href="#跨域同源策略" class="headerlink" title="跨域同源策略"></a>跨域同源策略</h4><h6 id="浏览器出于安全方面的考虑，只允许同源下的接口交互"><a href="#浏览器出于安全方面的考虑，只允许同源下的接口交互" class="headerlink" title="浏览器出于安全方面的考虑，只允许同源下的接口交互"></a>浏览器出于安全方面的考虑，只允许同源下的接口交互</h6><p><strong>同源</strong></p>
<ul>
<li>同协议</li>
<li>同域名</li>
<li>同端口</li>
</ul>
<p>一般跨域是b/s系统才有，c/s没有跨域问题</p>
<p><strong>跨域问题</strong></p>
<p>跨站 HTTP 请求(Cross-site HTTP request)是指发起请求的资源所在域不同于该请求所指向资源所在的域的 HTTP 请求。</p>
<p><code>跨域问题</code>只有在浏览器才会出现，javascript等脚本的主动http请求才会出现<code>跨域问题</code>。后端获取http数据不会存在跨域问题。<code>跨域问题</code>可以说是浏览器独有的（或者说http客户端独有的，这个其实看制定者是否遵循协议）。</p>
<p>跨站 HTTP正常请求，就是说请求还是会正常发送到服务器，服务器也给了响应，因为如果是http,服务器，是无状态的，来请求就会有相应；只是浏览器拦截了而已；<strong>浏览器还是会发出这个请求，但是它会拦截响应内容，如果发现响应header中”Access-Control-Allow-Origin”设置的允许访问的源没有包含当前源，则拒绝将数据返回给当前源。</strong></p>
<p>为了证明浏览器确实发出请求了，并且接收到数据了，可以用fidller抓包来分析一下，会发现相应报文里面有数据，只是浏览器拒绝返回给我们而已；</p>
<p><strong>浏览器同源策略的作用是防止跨站请求伪造。</strong></p>
<h4 id="如果想跨域请求第三方接口，或者-把自己的接口提供给第三方，要如-何做呢？"><a href="#如果想跨域请求第三方接口，或者-把自己的接口提供给第三方，要如-何做呢？" class="headerlink" title="如果想跨域请求第三方接口，或者 把自己的接口提供给第三方，要如 何做呢？"></a>如果想跨域请求第三方接口，或者 把自己的接口提供给第三方，要如 何做呢？</h4><p><strong>JSONP</strong></p>
<p>原理：</p>
<h6 id="同源策略只限制Ajax请求，不限制-script-标签加载js-可以通过-script-标签请求资源，并提前写好接收函数"><a href="#同源策略只限制Ajax请求，不限制-script-标签加载js-可以通过-script-标签请求资源，并提前写好接收函数" class="headerlink" title="同源策略只限制Ajax请求，不限制 script 标签加载js.可以通过 script 标签请求资源，并提前写好接收函数"></a>同源策略只限制Ajax请求，不限制 script 标签加载js.可以通过 script 标签请求资源，并提前写好接收函数</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script src=“http:/</span><span class="regexp">/api.jirengu.com/g</span>etWeather.php?callback=handleData”&gt;</span><br></pre></td></tr></table></figure>
<h6 id="服务器收到请求后，从-callback-参数中得到-fn-handleData-然后把请求的结果包装，变成fn-res-的形式返回"><a href="#服务器收到请求后，从-callback-参数中得到-fn-handleData-然后把请求的结果包装，变成fn-res-的形式返回" class="headerlink" title="服务器收到请求后，从 callback 参数中得到 fn(handleData),然后把请求的结果包装，变成fn(res)的形式返回"></a>服务器收到请求后，从 callback 参数中得到 fn(handleData),然后把请求的结果包装，变成fn(res)的形式返回</h6><h5 id="script-里面的资源加载后会当成-js-执行，就会执行-handleData-res-我们就拿到了请求的数据"><a href="#script-里面的资源加载后会当成-js-执行，就会执行-handleData-res-我们就拿到了请求的数据" class="headerlink" title="script 里面的资源加载后会当成 js 执行，就会执行 handleData(res),我们就拿到了请求的数据"></a>script 里面的资源加载后会当成 js 执行，就会执行 handleData(res),我们就拿到了请求的数据</h5><h4 id="使用promise封装一个-JSONP-基于后端支持的情况，即后端将数据封装在函数中"><a href="#使用promise封装一个-JSONP-基于后端支持的情况，即后端将数据封装在函数中" class="headerlink" title="使用promise封装一个 JSONP (基于后端支持的情况，即后端将数据封装在函数中)"></a>使用promise封装一个 JSONP (基于后端支持的情况，即后端将数据封装在函数中)</h4>
        
          <p class="article-more-link">
            <a href="/2020/05/22/跨域/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/22/跨域/" data-id="ckb7mn2la001czkw11fobgja2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-promise" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/20/promise/" class="article-date">
  <time datetime="2020-05-20T06:59:31.000Z" itemprop="datePublished">2020-05-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/20/promise/">promise</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>()接受两个函数参数对象 此时状态为 pending，resolve 和 reject </span><br><span class="line">执行resolve()后 promise的状态变为 已执行（fullfilled） 代表成功执行</span><br><span class="line">执行reject() 代表执行失败 failed</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    reject(<span class="string">"拒绝"</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="params">value</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//代表promise函数执行成功后的回调，value为执行后得到的数据</span></span><br><span class="line">&#125;,reason =&gt;&#123;</span><br><span class="line">    <span class="comment">//执行失败后执行的函数</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="JS任务优先级"><a href="#JS任务优先级" class="headerlink" title="JS任务优先级"></a>JS任务优先级</h4><p>代码执行优先级从上到下一次执行</p>
<ul>
<li>同步代码块 </li>
<li>微任务队列<ul>
<li>promise 的 then() 会放入微任务队列执行（在执行完 resolve后返回状态后放入微任务队列）</li>
</ul>
</li>
<li>宏任务队列<ul>
<li>setTimeOut 会放入宏任务队列执行</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">	 <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                resolve(); <span class="comment">// 生成微任务放入微任务队列</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">"settimeout"</span>);</span><br><span class="line">            &#125;, <span class="number">0</span>); <span class="comment">// 宏任务</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">value</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'成功'</span>))</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"案例"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出顺序为 "案例" 》 "settimeout" 》 "成功"</span></span><br></pre></td></tr></table></figure>
<h4 id="then-层层传递"><a href="#then-层层传递" class="headerlink" title="then 层层传递"></a>then 层层传递</h4><h6 id="promise-then-也是一个-promise"><a href="#promise-then-也是一个-promise" class="headerlink" title="promise.then() 也是一个 promise"></a>promise.then() 也是一个 promise</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// resolve("一瓶可乐")  resolve 和 reject 一次只能返回一种结果，不可能又成功又失败</span></span><br><span class="line">    reject(<span class="string">"涨价了"</span>);</span><br><span class="line">&#125;).then()  <span class="comment">//此处不处理，结果会向下传递</span></span><br><span class="line">.then(<span class="literal">null</span>,err=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"失败的原因"</span>+err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolv, reject</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//resolve("fullfilled")</span></span><br><span class="line">          reject(<span class="string">"rejected"</span>)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> p2 = p1.then(</span><br><span class="line">          value =&gt; <span class="built_in">console</span>.log(value),</span><br><span class="line">          reason =&gt; <span class="built_in">console</span>.log(reason)</span><br><span class="line">          ).then(</span><br><span class="line">              a=&gt; <span class="built_in">console</span>.log(<span class="string">"成功"</span>),</span><br><span class="line">              b =&gt; <span class="built_in">console</span>.log(b)</span><br><span class="line">          )</span><br><span class="line">      </span><br><span class="line">      <span class="built_in">console</span>.log(p2) <span class="comment">//会发现它是一个 promise对象</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// .then() 本身返回的也是一个 promise对象 p2也是一个promise，所以它也有相应的.then()函数</span></span><br><span class="line">      <span class="comment">//此刻p1的结果为 rejected,所以p1.then会捕获到 reason 输出 rejected,而p2,我们没有显示的指定它是成功还是失败，默认是成功的，所以会监听到 成功 （此刻我们不能打印 a 的值，因为我们没有设置 例如使用 resolve（值） 或者 return（值））</span></span><br></pre></td></tr></table></figure>
<h5 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(成功)&#123;</span><br><span class="line">			resolve(data)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			reject(reason)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fn(arg).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(reason)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂案例 也就是使用 Promise 封装 ajax 的请求过程    </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIp</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">                xhr.open(<span class="string">'GET'</span>,</span><br><span class="line">                    <span class="string">'http://rap2.taobao.org:38080/app/mock/245421/getIp'</span>, <span class="literal">true</span>)</span><br><span class="line">                xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> retJson = <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">                    resolve(retJson.ip)</span><br><span class="line">                &#125;</span><br><span class="line">                xhr.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    reject(<span class="string">'获取IP失败'</span>)</span><br><span class="line">                &#125;</span><br><span class="line">                xhr.send()</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">return</span> promise</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> getCityFromIp = <span class="function"><span class="params">ip</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">                xhr.open(<span class="string">'GET'</span>,</span><br><span class="line">                    <span class="string">'http://rap2.taobao.org:38080/app/mock/245421/getCity?ip='</span> + ip, <span class="literal">true</span>)</span><br><span class="line">                xhr.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                    resolve(<span class="built_in">JSON</span>.parse(xhr.responseText).city)</span><br><span class="line">                &#125;</span><br><span class="line">                xhr.onerror = <span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="string">'获取city失败'</span>)</span><br><span class="line">                xhr.send()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Promise-封装-ajax-请求（上面也是）"><a href="#Promise-封装-ajax-请求（上面也是）" class="headerlink" title="Promise 封装 ajax 请求（上面也是）"></a>Promise 封装 ajax 请求（上面也是）</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;).then()   <span class="comment">//一般这样写，promise会立即执行，并在then()中做后续处理</span></span><br><span class="line"><span class="comment">//封装 ajax 这里只定义 promise 请求，未对请求结果做处理，在调用时处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRquest();</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>,url);</span><br><span class="line">        xhr.send();</span><br><span class="line">        xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="number">200</span>)&#123;</span><br><span class="line">                resolve(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.response))</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                reject(<span class="string">'请求失败'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            reject(<span class="keyword">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用时候使用.then()处理请求的返回结果</span></span><br><span class="line"><span class="comment">//第一个ajax 请求</span></span><br><span class="line">ajax(<span class="string">'getUser?参数...'</span>).then(</span><br><span class="line">						user =&gt;&#123;</span><br><span class="line">                            <span class="keyword">return</span> ajax(<span class="string">`getCourse?id=`</span>+user.id)</span><br><span class="line">                           <span class="comment">// consoel.log('user 是请求得到的结果')</span></span><br><span class="line">                        &#125;,</span><br><span class="line">    					reason =&gt;&#123;</span><br><span class="line">                            <span class="comment">//可以在此处单独处理getname 请求的错误信息</span></span><br><span class="line">                            consoel.log(<span class="string">'失败的原因reason'</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">					).then(</span><br><span class="line">						course =&gt;&#123;</span><br><span class="line">                            <span class="built_in">console</span>.log(<span class="string">'course 是根据上面一步的请求的user.id获取到的结果'</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">						).chtch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span><br><span class="line">   								<span class="built_in">console</span>.log(<span class="string">'在此处做统一的错误处理'</span>)</span><br><span class="line">					&#125;)</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="comment">//未使用 promise 之前 封装的 ajax 方法</span></span><br><span class="line"><span class="comment">//四个参数，请求url, 请求参数，请求成功的处理，请求失败的处理</span></span><br><span class="line"> <span class="keyword">const</span> request = <span class="function">(<span class="params">url,params,onsuccess,onerror</span>) =&gt;</span>&#123;</span><br><span class="line">     <span class="comment">//get 方式拼接参数 url 字符串 将传递的对象参数拆分后拼接</span></span><br><span class="line">     url = url+<span class="string">'?'</span>+<span class="built_in">Object</span>.entries(params).map(<span class="function"><span class="params">param</span> =&gt;</span> arr[<span class="number">0</span>]+<span class="string">'='</span>+arr[<span class="number">1</span>]).join(<span class="string">'&amp;'</span>);</span><br><span class="line">     <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRquest()</span><br><span class="line">     xhr.open(<span class="string">'GET'</span>,url,<span class="literal">true</span>); <span class="comment">// 第三个参数是否使用异步</span></span><br><span class="line">     xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span>(xhr.status == <span class="number">200</span> || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line">             <span class="comment">//请求成功执行  onsuccess函数</span></span><br><span class="line">             onsuccess(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">//请求失败执行 onerror函数</span></span><br><span class="line">             onerror()</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//xhr有默认的 error方法，把我们自定义的赋值给它</span></span><br><span class="line">     xhr.onerror = onerror</span><br><span class="line">     xhr.send()</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//调用</span></span><br><span class="line"> request(<span class="string">'url'</span>,&#123;<span class="attr">param</span>:<span class="string">'rel'</span>&#125;,</span><br><span class="line">        	data=&gt;&#123;</span><br><span class="line">     			consoel.log(<span class="string">'请求成功'</span>)</span><br><span class="line">    			 consoel.log(data)</span><br><span class="line"> 			&#125;,</span><br><span class="line">         ()=&gt;&#123;</span><br><span class="line">     			consoel.log(<span class="string">'异常'</span>)</span><br><span class="line">			 &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2020/05/20/promise/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/20/promise/" data-id="ckb7mn2k5000vzkw1n8cyd3se" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/promise/">promise</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mock数据" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/19/mock数据/" class="article-date">
  <time datetime="2020-05-19T08:35:44.000Z" itemprop="datePublished">2020-05-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/19/mock数据/">mock数据</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="简单的-node-js-服务器"><a href="#简单的-node-js-服务器" class="headerlink" title="简单的 node.js 服务器"></a>简单的 node.js 服务器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Node.js 模拟 server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//解析url 将url解析成对象</span></span><br><span class="line">    <span class="keyword">let</span> urlObj = url.parse(req.url);</span><br><span class="line">    <span class="comment">// console.log(urlObj)</span></span><br><span class="line">    <span class="comment">//如何在服务器中展示一个我们已经写好的html页面呢？</span></span><br><span class="line">    <span class="comment">//使用fs模块解析该文件，res返回即可</span></span><br><span class="line">    <span class="keyword">let</span> file =  fs.readFileSync(__dirname+<span class="string">'/index.html'</span>);</span><br><span class="line">    <span class="comment">//处理用户请求</span></span><br><span class="line">    <span class="keyword">if</span>(urlObj.pathname === <span class="string">'/getWeather'</span>)&#123;</span><br><span class="line">        res.end(<span class="built_in">JSON</span>.stringify(&#123;<span class="attr">data</span>:<span class="string">'晴朗'</span>&#125;))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res.end(file)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p><strong>对应的html代码</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span> = <span class="string">"weather"</span>&gt;</span>天气：<span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> $ = <span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">document</span>.querySelector(s);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span></span><br><span class="line"><span class="javascript">    xhr.open(<span class="string">'GET'</span>,<span class="string">'http://localhost:8888/getWeather'</span>,<span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    xhr.onload = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        $(<span class="string">'span'</span>).innerText = <span class="built_in">JSON</span>.parse(xhr.responseText).data;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    xhr.send();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="详解步骤"><a href="#详解步骤" class="headerlink" title="详解步骤"></a>详解步骤</h6><ul>
<li>使用node.js 创建一个 httpServer,监听端口 8888</li>
<li>为了让我们已有的html在服务器中运行，在服务器的代码中使用 fs模块取读文件，然后将结果返回到客户端，于是展现了我们的html 页面</li>
<li>html页面中的 javascript 代码中又向我们的server中发送了一个请求，server中接收到请求后根据请求的路径进行相应的响应处理</li>
</ul>
<h4 id="更完善的-server"><a href="#更完善的-server" class="headerlink" title="更完善的 server"></a>更完善的 server</h4>
        
          <p class="article-more-link">
            <a href="/2020/05/19/mock数据/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/19/mock数据/" data-id="ckb7mn2jx000qzkw192h90znn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mock/">mock</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-ajax" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/18/ajax/" class="article-date">
  <time datetime="2020-05-18T08:23:21.000Z" itemprop="datePublished">2020-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/18/ajax/">ajax</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="与后端交互的方式"><a href="#与后端交互的方式" class="headerlink" title="与后端交互的方式"></a>与后端交互的方式</h4><h6 id="1-Form-表单提交"><a href="#1-Form-表单提交" class="headerlink" title="1. Form 表单提交"></a>1. Form 表单提交</h6><h6 id="2-AJAX"><a href="#2-AJAX" class="headerlink" title="2. AJAX"></a>2. AJAX</h6><h6 id="3-WebSocket-可以由服务端主动发起"><a href="#3-WebSocket-可以由服务端主动发起" class="headerlink" title="3. WebSocket  可以由服务端主动发起"></a>3. WebSocket  可以由服务端主动发起</h6><h2 id="我们如何向服务器发送请求？"><a href="#我们如何向服务器发送请求？" class="headerlink" title="我们如何向服务器发送请求？"></a><strong>我们如何向服务器发送请求？</strong></h2><ol>
<li>用 form 可以发请求，但是会刷新页面或新开页面</li>
<li>用 a 可以发 get 请求，但是也会刷新页面或新开页面</li>
<li>用 img 可以发 get 请求，但是只能以图片的形式展示</li>
<li>用 link 可以发 get 请求，但是只能以 CSS、favicon 的形式展示</li>
<li>用 script 可以发 get 请求，但是只能以脚本的形式运行</li>
</ol>
<p>有没有什么方式，可以使用get、post、put、delete 请求都行，并且用任意的方式返回给浏览器展示？</p>
<p><strong>当然有，这个就是AJAX。</strong></p>
<p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）</p>
<p>Jesse James Garrett 讲同时满足以下技术取名叫做AJAX:<strong>异步的 JavaScript 和 XML。</strong></p>
<ol>
<li>使用 XMLHttpRequest 发请求</li>
<li>服务器返回 XML 格式的字符串 (当然现在基本上都是用json来传递数据了)</li>
<li>JS 解析 XML，并更新局部页面</li>
</ol>
<p>ajax使用内置的XMLHttpRequest 和 fetch 对象，实现和服 务端进行数据交互</p>
<p><strong>发送请求四步走</strong></p>
<ul>
<li>创建 xmlhttprequest对象</li>
<li>配置参数（请求携带的参数，参数类型等）</li>
<li>绑定事件 （请求的事件处理）</li>
<li>发送请求 （send()）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完整例子 GET 请求，参数在url中拼接</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'http://rap2api.taobao.org/app/mock/244238/weather?city=北京'</span></span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(xhr.readyState === <span class="number">4</span>) &#123; <span class="comment">// xhr.DONE === 4 也可</span></span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.parse(xhr.responseText))</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器异常'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 可选</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器异常'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">let</span> url = <span class="string">'http://rap2api.taobao.org/app/mock/244238/weather?city=北京'</span> </span><br><span class="line"><span class="keyword">let</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// onload 就不用了再判断状态了</span></span><br><span class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>((xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) || xhr.status === <span class="number">304</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(xhr.response)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'数据异常'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">xhr.responseType = <span class="string">'json'</span> <span class="comment">//兼容性稍微差一些</span></span><br><span class="line">xhr.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'服务器异常'</span>)</span><br><span class="line">&#125;</span><br><span class="line">xhr.send()</span><br></pre></td></tr></table></figure>
        
          <p class="article-more-link">
            <a href="/2020/05/18/ajax/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/18/ajax/" data-id="ckb7mn2kt0011zkw1uhk5kjzt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ajax/">ajax</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-http-session-cookie-token" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/17/http-session-cookie-token/" class="article-date">
  <time datetime="2020-05-17T07:56:00.000Z" itemprop="datePublished">2020-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/17/http-session-cookie-token/">http-session-cookie-token</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="http-无状态"><a href="#http-无状态" class="headerlink" title="http 无状态"></a>http 无状态</h4><h6 id="HTTP无状态协议，是指协议对于交互性场景没有记忆能力。无登录状态，即服务器不知道某个用户是否已登录过了-所以每次都要在交互场景-会话-中请求中带上上一次的请求信息，如账号、密码。明明只需要在-login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）"><a href="#HTTP无状态协议，是指协议对于交互性场景没有记忆能力。无登录状态，即服务器不知道某个用户是否已登录过了-所以每次都要在交互场景-会话-中请求中带上上一次的请求信息，如账号、密码。明明只需要在-login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）" class="headerlink" title="HTTP无状态协议，是指协议对于交互性场景没有记忆能力。无登录状态，即服务器不知道某个用户是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在/login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）"></a>HTTP无状态协议，是指协议对于交互性场景没有记忆能力。无登录状态，即服务器不知道某个用户是否已登录过了,所以每次都要在交互场景(会话)中请求中带上上一次的请求信息，如账号、密码。明明只需要在/login接口中，才需要对比数据库中的账号密码和客户端传的是否一致来确定合法性。这下在添加购物车中也需要再一次的进行同样的重复且没有必要的操作，即降低了响应速度，又对用户不友好（因为每次都需要填账号，密码）</h6><p>此时的服务器只处理用户发来的请求，并没有记录用户的登录状态，所以在某些需要登录操作的场景下，显得尤为不足</p>
<p>每次的请求都是独立的，它的执行情况和结果与前面的请求和之后的请求是无直接关系的，它不会受前面的请求应答情况直接影响，也不会直接影响后面的请求应答情况【无直接联系】【受直接影响】</p>
<p><strong>一种常见的对状态的误解：</strong></p>
<ol>
<li>有人在解释HTTP的无状态时，把它跟有连接对立，说是两种方式，也就是如果想不无状态，就必须有连接，但其实不然</li>
<li>有连接和无连接以及之后的Keep-Alive都是指TCP连接</li>
<li>有状态和无状态可以指TCP也可以指HTTP</li>
<li>TCP一直有状态，HTTP一直无状态，但是应用为了有状态，就给HTTP加了cookie和session机制，让使用http的应用也能有状态，但http还是无状态</li>
</ol>
<p>开始TCP是有连接，后来TCP无连接，再后来也就是现在TCP是Keep-Alive，有点像有连接</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>为了帮助服务器存储客户端状态，我们引入了cookie 和 session</p>
<p><strong>Cookie</strong></p>
<p>Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，<strong><em>浏览器把请求的网址连同该Cookie一同提交给服务器\</em></strong>。服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容</p>
<h2 id="Cookie的不可跨域名性"><a href="#Cookie的不可跨域名性" class="headerlink" title="Cookie的不可跨域名性"></a>Cookie的不可跨域名性</h2><p> 很多网站都会使用Cookie。例如，Google会向客户端颁发Cookie，Baidu也会向客户端颁发Cookie。那浏览器访问Google会不会也携带上Baidu颁发的Cookie呢？或者Google能不能修改Baidu颁发的Cookie呢？</p>
<p>答案是否定的。Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。</p>
<p>Cookie在客户端是由浏览器来管理的。浏览器能够保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站Cookie的依据是域名。Google与Baidu的域名不一样，因此Google不能操作Baidu的Cookie</p>
<p>实例</p>
<h6 id="1-在登录网站的时候选择记住密码，此时服务器会返回给浏览器一个set-cookie字段"><a href="#1-在登录网站的时候选择记住密码，此时服务器会返回给浏览器一个set-cookie字段" class="headerlink" title="1.在登录网站的时候选择记住密码，此时服务器会返回给浏览器一个set-cookie字段"></a>1.在登录网站的时候选择记住密码，此时服务器会返回给浏览器一个set-cookie字段</h6><h6 id="2-查看Chrome-浏览器中的cookie设置会发现刚刚服务器返回给我们的cookie"><a href="#2-查看Chrome-浏览器中的cookie设置会发现刚刚服务器返回给我们的cookie" class="headerlink" title="2.查看Chrome 浏览器中的cookie设置会发现刚刚服务器返回给我们的cookie"></a>2.查看Chrome 浏览器中的cookie设置会发现刚刚服务器返回给我们的cookie</h6><h6 id="3-观察服务器返回的cookie-发现和浏览器存储的是一致的"><a href="#3-观察服务器返回的cookie-发现和浏览器存储的是一致的" class="headerlink" title="3.观察服务器返回的cookie 发现和浏览器存储的是一致的"></a>3.观察服务器返回的cookie 发现和浏览器存储的是一致的</h6><h6 id="4-再次访问这个网站，发现不需要输入密码即可登录，此时观察请求头中的信息里面，浏览器把我们本地存储的cookie字段一并发送给了服务器"><a href="#4-再次访问这个网站，发现不需要输入密码即可登录，此时观察请求头中的信息里面，浏览器把我们本地存储的cookie字段一并发送给了服务器" class="headerlink" title="4.再次访问这个网站，发现不需要输入密码即可登录，此时观察请求头中的信息里面，浏览器把我们本地存储的cookie字段一并发送给了服务器"></a>4.再次访问这个网站，发现不需要输入密码即可登录，此时观察请求头中的信息里面，浏览器把我们本地存储的cookie字段一并发送给了服务器</h6><h2 id="Cookie-保存登录信息有多种方案"><a href="#Cookie-保存登录信息有多种方案" class="headerlink" title="Cookie 保存登录信息有多种方案"></a><strong>Cookie 保存登录信息有多种方案</strong></h2><ul>
<li>方案一：最直接的是把用户名与密码都保持到Cookie中，下次访问时检查Cookie中的用户名与密码，与数据库比较。这是一种比较危险的选择，一般不把密码等重要信息保存到Cookie中。</li>
<li>方案二：是把密码加密后保存到Cookie中，下次访问时解密并与数据库比较。这种方案略微安全一些。如果不希望保存密码，还可以把登录的时间戳保存到Cookie与数据库中，到时只验证用户名与登录时间戳就可以了。</li>
<li>方案三：只在登录时查询一次数据库，以后访问验证登录信息时不再查询数据库。实现方式是把账号按照一定的规则加密后，连同账号一块保存到Cookie中。下次访问时只需要判断账号的加密规则是否正确即可。</li>
</ul>
<h4 id="cookie的属性"><a href="#cookie的属性" class="headerlink" title="cookie的属性"></a>cookie的属性</h4><p>一般cookie所具有的属性，包括：</p>
<p>Domain：域，表示当前cookie所属于哪个域或子域下面。（上面说了 cookie不可跨域，也就是每个网站只能使用自己网站的cookie,不会发生错乱的情况）</p>
<p>对于服务器返回的Set-Cookie中，如果没有指定Domain的值，那么其Domain的值是默认为当前所提交的http的请求所对应的主域名的。比如访问 <a href="http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。" target="_blank" rel="noopener">http://www.example.com，返回一个cookie，没有指名domain值，那么其为值为默认的www.example.com。</a></p>
<p>Path：表示cookie的所属路径。</p>
<p>Expire time/Max-age：表示了cookie的有效期。expire的值，是一个时间，过了这个时间，该cookie就失效了。或者是用max-age指定当前cookie是在多长时间之后而失效。如果服务器返回的一个cookie，没有指定其expire time，那么表明此cookie有效期只是当前的session，即是session cookie，当前session会话结束后，就过期了。对应的，当关闭（浏览器中）该页面的时候，此cookie就应该被浏览器所删除了。</p>
<p>secure：表示该cookie只能用https传输。一般用于包含认证信息的cookie，要求传输此cookie的时候，必须用https传输。</p>
<p>httponly：表示此cookie必须用于http或https传输。这意味着，浏览器脚本，比如javascript中，是不允许访问操作此cookie的。</p>
<p><img src="E:/Git/newBlog/SheilaTing.github.io/source/img/http/cookie.png" alt></p>
<h4 id="解决无状态问题的例子"><a href="#解决无状态问题的例子" class="headerlink" title="解决无状态问题的例子"></a>解决无状态问题的例子</h4><p>让我们用几个例子来描述一下cookie和session机制之间的区别与联系。笔者曾经常去的一家咖啡店有喝5杯咖啡免费赠一杯咖啡的优惠，然而一次性消费5杯咖啡的机会微乎其微，这时就需要某种方式来纪录某位顾客的消费数量。想象一下其实也无外乎下面的几种方案： </p>
<p>  1、该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。 </p>
<p>  2、发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。 </p>
<p>  3、发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加一些消费信息。这种做法就是在服务器端保持状态。 </p>
<p>  由于HTTP协议是无状态的，而出于种种考虑也不希望使之成为有状态的，因此，后面两种方案就成为现实的选择。具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 </p>
<h4 id="session"><a href="#session" class="headerlink" title="session"></a>session</h4><p><strong>理解session机制</strong> </p>
<p><img src="../img/http/session.jpg" style="zoom:200%;"></p>
<p>参考若愚老师的文章 <a href="https://zhuanlan.zhihu.com/p/58490770" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58490770</a></p>
<p><strong>session 的安全策略 以及 session 机制的缺点</strong></p>
<h6 id="万一sessionId被泄露，那么请求就可以被伪造，例如被-XSS攻击获取这个cookie中的sessionId"><a href="#万一sessionId被泄露，那么请求就可以被伪造，例如被-XSS攻击获取这个cookie中的sessionId" class="headerlink" title="万一sessionId被泄露，那么请求就可以被伪造，例如被 XSS攻击获取这个cookie中的sessionId"></a>万一sessionId被泄露，那么请求就可以被伪造，例如被 XSS攻击获取这个cookie中的sessionId</h6><p><strong>解决如何使session更安全</strong></p>
<h6 id="1-服务器端设置http-only-这样客户端就不能通过document-cookie来获取cookie，也就避免了xss攻击"><a href="#1-服务器端设置http-only-这样客户端就不能通过document-cookie来获取cookie，也就避免了xss攻击" class="headerlink" title="1.服务器端设置http-only,这样客户端就不能通过document.cookie来获取cookie，也就避免了xss攻击"></a>1.服务器端设置http-only,这样客户端就不能通过document.cookie来获取cookie，也就避免了xss攻击</h6><h6 id="2-使用https，加secure字段，secure：当-secure-值为-true-时，cookie-在-HTTP-中是无效，在-HTTPS-中才有效"><a href="#2-使用https，加secure字段，secure：当-secure-值为-true-时，cookie-在-HTTP-中是无效，在-HTTPS-中才有效" class="headerlink" title="2.使用https，加secure字段，secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效"></a>2.使用https，加secure字段，secure：当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效</h6><p><strong>session的缺点</strong></p>
<h6 id="1-使用场景限制-cookie-只能在浏览器中使用，换了其他客户端，小程序没有Cookie自然无法使用这个机制"><a href="#1-使用场景限制-cookie-只能在浏览器中使用，换了其他客户端，小程序没有Cookie自然无法使用这个机制" class="headerlink" title="1.使用场景限制 cookie 只能在浏览器中使用，换了其他客户端，小程序没有Cookie自然无法使用这个机制"></a>1.使用场景限制 cookie 只能在浏览器中使用，换了其他客户端，小程序没有Cookie自然无法使用这个机制</h6><h6 id="2-这个机制，服务器端需要创建session-对象，如果将session放在内存中，那如果有1000个对象访问那内存中岂不是又1000个对象，如果每个对象中的数据又很多，那内存会不会爆掉。不存在内存中，那么把它存入数据库中，例如redis数据库，那如果我们使用分布式服务器，又要考虑数据库的复用性，服务器端要做更多的事情来处理"><a href="#2-这个机制，服务器端需要创建session-对象，如果将session放在内存中，那如果有1000个对象访问那内存中岂不是又1000个对象，如果每个对象中的数据又很多，那内存会不会爆掉。不存在内存中，那么把它存入数据库中，例如redis数据库，那如果我们使用分布式服务器，又要考虑数据库的复用性，服务器端要做更多的事情来处理" class="headerlink" title="2.这个机制，服务器端需要创建session 对象，如果将session放在内存中，那如果有1000个对象访问那内存中岂不是又1000个对象，如果每个对象中的数据又很多，那内存会不会爆掉。不存在内存中，那么把它存入数据库中，例如redis数据库，那如果我们使用分布式服务器，又要考虑数据库的复用性，服务器端要做更多的事情来处理"></a>2.这个机制，服务器端需要创建session 对象，如果将session放在内存中，那如果有1000个对象访问那内存中岂不是又1000个对象，如果每个对象中的数据又很多，那内存会不会爆掉。不存在内存中，那么把它存入数据库中，例如redis数据库，那如果我们使用分布式服务器，又要考虑数据库的复用性，服务器端要做更多的事情来处理</h6><h4 id="JWT鉴权机制（解决session机制的弊端）JSON-web-token"><a href="#JWT鉴权机制（解决session机制的弊端）JSON-web-token" class="headerlink" title="JWT鉴权机制（解决session机制的弊端）JSON web token"></a>JWT鉴权机制（解决session机制的弊端）JSON web token</h4><p><img src="../img/http/jwt.jpg" style="zoom:200%;"></p>
<p>第四步.token字符串的规则分为三部分，str1:鉴权机制，算法  str2：用户信息  str3:HMAC(str1+str2，secret_key)</p>
<p>服务器把token发给浏览器，客户端存储下来，下次请求带上token即可，服务器端收到后，验证token,服务器使用 HMA()方法把客户端发来的数据拆开（base64先解密，因为发之前加密了），然后加上自己的 secretkey经过运算得到str3的值如果与发送来的str3一致，认证成功</p>
<p>优点就是session 的缺点，缺点：增加了服务器端计算的压力</p>
<p>还有一个缺点：token是有过期时间的，如果用户刚登录就点击了注销，那么此时token的过期时间还没到，依然是有效的，token的续期问题。。。。。发现越是想要做的安全，服务器还是要存储一些东西，反而变得复杂了，哈哈</p>
<h4 id="Auth2-机制-（Open-Authorization-开放授权）"><a href="#Auth2-机制-（Open-Authorization-开放授权）" class="headerlink" title="Auth2 机制 （Open Authorization 开放授权）"></a>Auth2 机制 （Open Authorization 开放授权）</h4><h6 id="是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息"><a href="#是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息" class="headerlink" title="是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息"></a>是为用户资源的授权定义了一个安全、开放及简单的标准，第三方无需知道用户的账号及密码，就可获取到用户的授权信息</h6><p><strong>流程</strong></p>
<p><img src="../img/http/auth2.jpg" style="zoom:200%;"></p>
<p>参考这个：<a href="https://www.barretlee.com/blog/2016/01/10/oauth2-introduce/" target="_blank" rel="noopener">https://www.barretlee.com/blog/2016/01/10/oauth2-introduce/</a></p>
<h4 id="XSS攻击-（跨站脚本攻击）"><a href="#XSS攻击-（跨站脚本攻击）" class="headerlink" title="XSS攻击 （跨站脚本攻击）"></a>XSS攻击 （跨站脚本攻击）</h4><p>xss就是攻击者在web页面插入恶意的Script代码，当用户浏览该页之时，嵌入其中web里面的Script代码会被执行，从而达到恶意攻击用户的特殊目的。例如我们允许客户端上传图片</p>
<p>造成 XSS 有几个要点：</p>
<ol>
<li><p>恶意用户可以提交内容</p>
</li>
<li><p>提交的内容可以显示在另一个用户的页面上</p>
</li>
<li><p>这些内容未经<strong>过滤</strong>，直接<strong>运行</strong>在另一个用户的页面上</p>
</li>
</ol>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>假设我们有一个评论系统。</p>
<p>用户 A 提交评论「小谷你好」到服务器，然后用户 B 来访问网站，看到了 A 的评论「小谷你好」，这里没有 XSS。</p>
<p>恶意用户 H 提交评论「<script>console.log(document.cookie)</script>」，然后用户 B 来访问网站，这段脚本在 B 的浏览器直接执行，恶意用户 H 的脚本就可以任意操作 B 的 cookie，而 B 对此毫无察觉。有了 cookie，恶意用户 H 就可以伪造 B 的登录信息，随意访问 B 的隐私了。而 B 始终被蒙在鼓里。</p>
<p>所以我们前后端要做的就是要处理用户的输入，后端模板中不要直接展示用户的输出，可以把尖括号改为html实体符号输出，前端避免直接使用dom.html()来输出内容，尽量使用dom.text();</p>
<p>js 中不要用 eval (这个我还真不知道哎)</p>
<h4 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h4><h6 id="CSRF（Cross-site-request-forgery），中文名称：跨站请求伪造，也被称为：one-click-attack-session-riding，缩写为：CSRF-XSRF。"><a href="#CSRF（Cross-site-request-forgery），中文名称：跨站请求伪造，也被称为：one-click-attack-session-riding，缩写为：CSRF-XSRF。" class="headerlink" title="CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。"></a>CSRF（Cross-site request forgery），中文名称：跨站请求伪造，也被称为：one click attack/session riding，缩写为：CSRF/XSRF。</h6><p> CSRF的防御可以从服务端和客户端两方面着手，防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p>
<p>　　服务器在返回用户响应的时候生成一个随机数，set到客户端的 cookie中，并且在页面上写一个隐藏的input 值就是这个随机数，那么每次向服务器发送请求时都会带上这个csrf_token服务器通过cookie拿到这个值，以及页面隐藏的这个值，对比如果一致则执行，不一致就拒绝</p>
<p>想一下：如果攻击者去伪造这个随机数，服务器发现与页面传来的不一致不会执行。</p>
<p>　　</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/05/17/http-session-cookie-token/" data-id="ckb7mn2jd000hzkw12ac0fykg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/http/">http</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bom/">bom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/">dom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https基础/">https基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站建站案例练习/">网站建站案例练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/bom/" style="font-size: 10px;">bom</a> <a href="/tags/css/" style="font-size: 20px;">css</a> <a href="/tags/dom/" style="font-size: 10px;">dom</a> <a href="/tags/http/" style="font-size: 13.33px;">http</a> <a href="/tags/https基础/" style="font-size: 10px;">https基础</a> <a href="/tags/js/" style="font-size: 16.67px;">js</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/node-js/" style="font-size: 10px;">node.js</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 13.33px;">react</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/webpack/" style="font-size: 13.33px;">webpack</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/网站建站案例练习/" style="font-size: 10px;">网站建站案例练习</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/06/09/react-生命周期等/">react 生命周期等</a>
          </li>
        
          <li>
            <a href="/2020/06/06/手写-react/">手写 react</a>
          </li>
        
          <li>
            <a href="/2020/06/01/webpack-笔记/">webpack 笔记</a>
          </li>
        
          <li>
            <a href="/2020/06/01/node-js-commonJs规范/">node.js commonJs规范</a>
          </li>
        
          <li>
            <a href="/2020/05/31/前端模块化、工程化/">前端模块化、工程化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>