<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>SheilaTing 的博客呀</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SheilaTing 的博客呀">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="SheilaTing 的博客呀">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="SheilaTing 的博客呀">
  
    <link rel="alternate" href="/atom.xml" title="SheilaTing 的博客呀" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">SheilaTing 的博客呀</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-用户体验以及产品相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/26/用户体验以及产品相关/" class="article-date">
  <time datetime="2020-07-26T04:26:33.000Z" itemprop="datePublished">2020-07-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/26/用户体验以及产品相关/">用户体验以及产品相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="用户体验要素-书"><a href="#用户体验要素-书" class="headerlink" title="用户体验要素 书"></a>用户体验要素 书</h4><p><a href="https://www.cnblogs.com/frankfang/archive/2011/04/21/2023618.html" target="_blank" rel="noopener">https://www.cnblogs.com/frankfang/archive/2011/04/21/2023618.html</a></p>
<h4 id="网站开发的流程"><a href="#网站开发的流程" class="headerlink" title="网站开发的流程"></a>网站开发的流程</h4><ol>
<li>立项 - 确定要做，确定人员，确定预算等</li>
<li>需求 - 需求收集和分析<ul>
<li>收集比分析更难，有的时候用户也不知道自己的需求</li>
<li>亨利·福特曾说过，「如果我最初是问消费者他们想要什么，他们应该是会告诉我，要一匹更快的马！」</li>
<li>可以用「用例图」来分析需求</li>
</ul>
</li>
<li>可行性分析</li>
<li>系统设计（功能设计、框架设计）<ul>
<li>UML 图、时序图等</li>
</ul>
</li>
<li>原型设计（草图、线框图）<ul>
<li>草图用纸和笔画</li>
<li>线框图可以用 Balsamiq</li>
</ul>
</li>
<li>交互设计<ul>
<li>可以用 Axure RP、墨刀、Sketch.app</li>
</ul>
</li>
<li>视觉设计<ul>
<li>可以用 Photoshop、Fireworks、Sketch.app</li>
</ul>
</li>
<li>程序开发</li>
<li>测试</li>
<li>功能预演</li>
<li>内测</li>
<li><p>灰度发布</p>
<p>13.正式发布</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/26/用户体验以及产品相关/" data-id="ckd2l3zje001kkcw1yqck902r" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/product/">product</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-防抖与节流" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/21/防抖与节流/" class="article-date">
  <time datetime="2020-07-21T05:37:46.000Z" itemprop="datePublished">2020-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/21/防抖与节流/">防抖与节流</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="防抖概念"><a href="#防抖概念" class="headerlink" title="防抖概念"></a>防抖概念</h4><h6 id="在一段时间内例如10秒内，如果用户持续触发这个事件，那么时间就重新计时，只有当用户触发完这个事件后的时间超过10s-才执行这个事件"><a href="#在一段时间内例如10秒内，如果用户持续触发这个事件，那么时间就重新计时，只有当用户触发完这个事件后的时间超过10s-才执行这个事件" class="headerlink" title="在一段时间内例如10秒内，如果用户持续触发这个事件，那么时间就重新计时，只有当用户触发完这个事件后的时间超过10s 才执行这个事件"></a>在一段时间内例如10秒内，如果用户持续触发这个事件，那么时间就重新计时，只有当用户触发完这个事件后的时间超过10s 才执行这个事件</h6><p><strong>应用场景</strong></p>
<h6 id="页面上的搜索框，我们监听了它的change事件，只要一输入内容，我们就像后端发送请求获取相应的数据，此时就会非常耗性能，因为我们本来希望的是当用户输入完完整的搜索条件后，我们才去发送请求，现在变成了只要输入我们就发送请求，这显然是不合理的，所以此时我们就可以使用防抖函数，来对我们的change事件做一层包装，"><a href="#页面上的搜索框，我们监听了它的change事件，只要一输入内容，我们就像后端发送请求获取相应的数据，此时就会非常耗性能，因为我们本来希望的是当用户输入完完整的搜索条件后，我们才去发送请求，现在变成了只要输入我们就发送请求，这显然是不合理的，所以此时我们就可以使用防抖函数，来对我们的change事件做一层包装，" class="headerlink" title="页面上的搜索框，我们监听了它的change事件，只要一输入内容，我们就像后端发送请求获取相应的数据，此时就会非常耗性能，因为我们本来希望的是当用户输入完完整的搜索条件后，我们才去发送请求，现在变成了只要输入我们就发送请求，这显然是不合理的，所以此时我们就可以使用防抖函数，来对我们的change事件做一层包装，"></a>页面上的搜索框，我们监听了它的change事件，只要一输入内容，我们就像后端发送请求获取相应的数据，此时就会非常耗性能，因为我们本来希望的是当用户输入完完整的搜索条件后，我们才去发送请求，现在变成了只要输入我们就发送请求，这显然是不合理的，所以此时我们就可以使用防抖函数，来对我们的change事件做一层包装，</h6><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//js 手写 防抖函数 这里我们仿照 underscore.js 来写</span></span><br><span class="line"><span class="comment">// 因为只是包装我们原来的函数，也就是说当change 时我们调用包装后返回的函数，所以返回一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fun,wait</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">let</span> timeout</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> args = <span class="built_in">arguments</span> <span class="comment">// 函数参数</span></span><br><span class="line">        clearTimeout(timeout) <span class="comment">// 清除定时器，下次触发这个函数时，先清除这个定时器</span></span><br><span class="line">        <span class="comment">//然后再重新生成一个定时器</span></span><br><span class="line">        <span class="keyword">let</span> _this = <span class="keyword">this</span> <span class="comment">// 保存调用者的 this</span></span><br><span class="line">        <span class="comment">//使用定时器，wait 时间后再执行这个函数</span></span><br><span class="line">        timout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            fun.apply(_this,args) <span class="comment">// 如果用箭头函数就直接绑定 this</span></span><br><span class="line">        &#125;,wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//之所以要清除这个定时器，是因为，一旦我们点击的速度太快，在wait时间内点击，因为你点击一次，就会执行一次，点击次数太多，定时器就一直执行，你会看到它在不间断的执行，因为执行的可能是你上上此的点击事件，这显然不是我们想要的结果，所以，为了解决这个问题，如果用户触发这个事件，那么判断下上次的有没有执行完，如果没有就清除掉，这样就会像我们预期的一样执行了。</span></span><br></pre></td></tr></table></figure>
<h4 id="节流概念"><a href="#节流概念" class="headerlink" title="节流概念"></a>节流概念</h4><h6 id="对于上面的例子，当然我们也可以不监听输入框的change事件而是给页面上加一个搜索按钮，当用户点击搜索时再发送请求，但这样会有另一个问题，那就是假如这个用户比较手欠，它一直点搜索，那么我们就要像服务器一直发送请求，异步请求比较耗时，可能造成数据堵塞，进而引发页面卡顿现象，这个时候我们就可以使用节流函数来对我们的函数做一层包装，在一段时间内例如10s，我们只发送一次请求，用户在这个时间内点击了再多次我们也只发送一次请求，减少对服务器的请求次数"><a href="#对于上面的例子，当然我们也可以不监听输入框的change事件而是给页面上加一个搜索按钮，当用户点击搜索时再发送请求，但这样会有另一个问题，那就是假如这个用户比较手欠，它一直点搜索，那么我们就要像服务器一直发送请求，异步请求比较耗时，可能造成数据堵塞，进而引发页面卡顿现象，这个时候我们就可以使用节流函数来对我们的函数做一层包装，在一段时间内例如10s，我们只发送一次请求，用户在这个时间内点击了再多次我们也只发送一次请求，减少对服务器的请求次数" class="headerlink" title="对于上面的例子，当然我们也可以不监听输入框的change事件而是给页面上加一个搜索按钮，当用户点击搜索时再发送请求，但这样会有另一个问题，那就是假如这个用户比较手欠，它一直点搜索，那么我们就要像服务器一直发送请求，异步请求比较耗时，可能造成数据堵塞，进而引发页面卡顿现象，这个时候我们就可以使用节流函数来对我们的函数做一层包装，在一段时间内例如10s，我们只发送一次请求，用户在这个时间内点击了再多次我们也只发送一次请求，减少对服务器的请求次数"></a>对于上面的例子，当然我们也可以不监听输入框的change事件而是给页面上加一个搜索按钮，当用户点击搜索时再发送请求，但这样会有另一个问题，那就是假如这个用户比较手欠，它一直点搜索，那么我们就要像服务器一直发送请求，异步请求比较耗时，可能造成数据堵塞，进而引发页面卡顿现象，这个时候我们就可以使用节流函数来对我们的函数做一层包装，在一段时间内例如10s，我们只发送一次请求，用户在这个时间内点击了再多次我们也只发送一次请求，减少对服务器的请求次数</h6><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// js 手写 节流函数  使用时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> time = <span class="number">0</span>;  <span class="comment">// 闭包，上一次执行的时间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        args = <span class="built_in">arguments</span></span><br><span class="line">        _this = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">let</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>().valueOf() <span class="comment">// 当前时间</span></span><br><span class="line">        <span class="keyword">if</span>(now - time &gt; wait)&#123;</span><br><span class="line">            fun.apply(_this,args)</span><br><span class="line">            time = now</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首次触发这个函数会立即执行，同时把当前的时间赋值给时间戳（上次的执行时间），再次触发，判断当前的时间和上次的时间的间隔是否大于wait的时间，大于则执行，不大于则不执行</span></span><br><span class="line"><span class="comment">// setTimeout 方式实现</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fun,wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timeout,args,_this;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        args = <span class="built_in">arguments</span></span><br><span class="line">        _this = <span class="keyword">this</span></span><br><span class="line">        <span class="comment">//首次timout 不存在取反为true执行,</span></span><br><span class="line">        <span class="keyword">if</span>(!timeout)&#123;</span><br><span class="line">              timeout = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                 timeout = <span class="literal">null</span> <span class="comment">// 置空，否则永远进不了 if </span></span><br><span class="line">            	 fun.apply(_this,args)</span><br><span class="line">       		 &#125;,wait)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用setTimeout 延迟执行的特点，第一次将timeout 初始为空，取反后判断是否为true,只有当定时器为空时，才去执行这个定时器函数，并在函数内将上一次的定时器置为null,其实可以不是定时器对象，随便定义一个变量判断也可以,第一次触发会延迟wait时间执行，此时 timout 有值,!timeout 为 false,此时执行定时器里面的函数，如果用户此时再发送事件请求，因为!timeout为false,所以不会进入执行体内，实现了想要的效果。</span></span><br><span class="line"><span class="comment">// 其实就是在定时器执行执行的过程中我们设置一个标记，来让后续的请求都无法进入到执行体内，只有当执行体内的函数执行完成后，再改变这个条件，接收新的请求！</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/21/防抖与节流/" data-id="ckd2l3zjo001rkcw1bza9try7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js性能/">js性能</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-html-css-复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/html-css-复习/" class="article-date">
  <time datetime="2020-07-14T02:57:10.000Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/html-css-复习/">html-css 复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="动态-rem"><a href="#动态-rem" class="headerlink" title="动态 rem"></a>动态 rem</h4><p><a href="https://www.jianshu.com/p/b13e32321459" target="_blank" rel="noopener">https://www.jianshu.com/p/b13e32321459</a></p>
<h4 id="data-set"><a href="#data-set" class="headerlink" title="data-set"></a>data-set</h4><h6 id="自定义属性-data-属性名，可以存储一些数据，例如："><a href="#自定义属性-data-属性名，可以存储一些数据，例如：" class="headerlink" title="自定义属性 data-属性名，可以存储一些数据，例如："></a>自定义属性 data-属性名，可以存储一些数据，例如：</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div"</span> <span class="attr">data-color</span> = <span class="string">"red"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// js中</span><br><span class="line">node.dataset.color //  等于 red</span><br><span class="line">//也可以这样</span><br><span class="line">Object.assign(node.style,node.dataset) // 自动样式就变红了</span><br></pre></td></tr></table></figure>
<h4 id="首页白屏，无样式内容闪烁"><a href="#首页白屏，无样式内容闪烁" class="headerlink" title="首页白屏，无样式内容闪烁"></a>首页白屏，无样式内容闪烁</h4><ul>
<li><p><script> 加载-&gt;执行-&gt;往后解析；加载会阻塞解析，多个JS按顺序执行</p>
</li>
<li><p><script async> 不影响DOM的解析和其他资源的加载，特例独行，不保证顺序，不保证时机</p>
</li>
<li><p><script defer> 不影响DOM的解析和其他资源的加载，但是会保证在DOM资源准备就绪后再执行，并且对于多个defer的外置js按顺序执行</p>
</li>
</ul>
<h6 id="白屏的原因一般就是js的加载阻碍了-dom-和-css-的加载，一般把-js-放在body-后面，css的加载是非阻塞的，无内容闪烁，就是页面没有样式，一般把样式文件加载放在-header中。"><a href="#白屏的原因一般就是js的加载阻碍了-dom-和-css-的加载，一般把-js-放在body-后面，css的加载是非阻塞的，无内容闪烁，就是页面没有样式，一般把样式文件加载放在-header中。" class="headerlink" title="白屏的原因一般就是js的加载阻碍了 dom 和 css 的加载，一般把 js 放在body 后面，css的加载是非阻塞的，无内容闪烁，就是页面没有样式，一般把样式文件加载放在 header中。"></a>白屏的原因一般就是js的加载阻碍了 dom 和 css 的加载，一般把 js 放在body 后面，css的加载是非阻塞的，无内容闪烁，就是页面没有样式，一般把样式文件加载放在 header中。</h6><h4 id="浏览器的渲染机制"><a href="#浏览器的渲染机制" class="headerlink" title="浏览器的渲染机制"></a>浏览器的渲染机制</h4><h6 id="解析HTML，构建DOM树；解析CSS构建CSSOM树；组合成渲染树；计算节点的位置和几何结构；绘制到屏幕上"><a href="#解析HTML，构建DOM树；解析CSS构建CSSOM树；组合成渲染树；计算节点的位置和几何结构；绘制到屏幕上" class="headerlink" title="解析HTML，构建DOM树；解析CSS构建CSSOM树；组合成渲染树；计算节点的位置和几何结构；绘制到屏幕上"></a>解析HTML，构建DOM树；解析CSS构建CSSOM树；组合成渲染树；计算节点的位置和几何结构；绘制到屏幕上</h6><h6 id="回流：重新计算元素的几何尺寸，位置。添加删除元素，修改盒模型属性，display-none等，引起自己尺寸、位置变化或者其他元素尺寸位置的变化。"><a href="#回流：重新计算元素的几何尺寸，位置。添加删除元素，修改盒模型属性，display-none等，引起自己尺寸、位置变化或者其他元素尺寸位置的变化。" class="headerlink" title="回流：重新计算元素的几何尺寸，位置。添加删除元素，修改盒模型属性，display: none等，引起自己尺寸、位置变化或者其他元素尺寸位置的变化。"></a>回流：重新计算元素的几何尺寸，位置。添加删除元素，修改盒模型属性，display: none等，引起自己尺寸、位置变化或者其他元素尺寸位置的变化。</h6><h6 id="重绘：重新绘制全部或者部分界面。修改颜色、背景色等。不需要重新计算位置，只需要重新绘制效果。"><a href="#重绘：重新绘制全部或者部分界面。修改颜色、背景色等。不需要重新计算位置，只需要重新绘制效果。" class="headerlink" title="重绘：重新绘制全部或者部分界面。修改颜色、背景色等。不需要重新计算位置，只需要重新绘制效果。"></a>重绘：重新绘制全部或者部分界面。修改颜色、背景色等。不需要重新计算位置，只需要重新绘制效果。</h6><h6 id="优化：一次性修改样式；给动画使用绝对定位或者transfrom减小影响面；在DOM离线状态下修改样式。"><a href="#优化：一次性修改样式；给动画使用绝对定位或者transfrom减小影响面；在DOM离线状态下修改样式。" class="headerlink" title="优化：一次性修改样式；给动画使用绝对定位或者transfrom减小影响面；在DOM离线状态下修改样式。"></a>优化：一次性修改样式；给动画使用绝对定位或者transfrom减小影响面；在DOM离线状态下修改样式。</h6><h6 id="因为如果不使用绝对定位它就在普通流中，动画每执行一次，就会影响到普通流中的dom，造成页面回流和重回，绝对定位后脱离了文档流，减小了影响面。"><a href="#因为如果不使用绝对定位它就在普通流中，动画每执行一次，就会影响到普通流中的dom，造成页面回流和重回，绝对定位后脱离了文档流，减小了影响面。" class="headerlink" title="因为如果不使用绝对定位它就在普通流中，动画每执行一次，就会影响到普通流中的dom，造成页面回流和重回，绝对定位后脱离了文档流，减小了影响面。"></a>因为如果不使用绝对定位它就在普通流中，动画每执行一次，就会影响到普通流中的dom，造成页面回流和重回，绝对定位后脱离了文档流，减小了影响面。</h6><h4 id="css-盒模型"><a href="#css-盒模型" class="headerlink" title="css 盒模型"></a>css 盒模型</h4><h6 id="IE-盒模型-和-标准盒模型"><a href="#IE-盒模型-和-标准盒模型" class="headerlink" title="IE 盒模型 和 标准盒模型"></a>IE 盒模型 和 标准盒模型</h6><h6 id="IE-盒模型寬度-border-padding-content"><a href="#IE-盒模型寬度-border-padding-content" class="headerlink" title="IE 盒模型寬度 = border + padding + content"></a>IE 盒模型寬度 = border + padding + content</h6><h6 id="標準盒模型-寬度-內容的寬度"><a href="#標準盒模型-寬度-內容的寬度" class="headerlink" title="標準盒模型 寬度 = 內容的寬度"></a>標準盒模型 寬度 = 內容的寬度</h6><h6 id="使用-box-sizing-设置盒模型-默认为-contentbox-标准盒模型，IE盒模型：border-box-有时候还挺好用"><a href="#使用-box-sizing-设置盒模型-默认为-contentbox-标准盒模型，IE盒模型：border-box-有时候还挺好用" class="headerlink" title="使用 box-sizing 设置盒模型 默认为 contentbox 标准盒模型，IE盒模型：border-box (有时候还挺好用)"></a>使用 box-sizing 设置盒模型 默认为 contentbox 标准盒模型，IE盒模型：border-box (有时候还挺好用)</h6><h4 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h4><h4 id="svg-教程地址"><a href="#svg-教程地址" class="headerlink" title="svg 教程地址"></a>svg 教程地址</h4><p> <a href="https://jirengu.github.io/svg-you-should-know/zh-cn/chapter1/svg_icon.html">https://jirengu.github.io/svg-you-should-know/zh-cn/chapter1/svg_icon.html</a>)</p>
</script></p></li></ul>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/14/html-css-复习/" data-id="ckd2l3zhn000hkcw1qxid1he6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/html-css/">html-css</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-vue-account" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/24/vue-account/" class="article-date">
  <time datetime="2020-06-24T07:59:17.000Z" itemprop="datePublished">2020-06-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/24/vue-account/">vue-account</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="搭建vue项目环境-vue-cli-3-0-2-0-使用-vue-init-webpack-项目名称"><a href="#搭建vue项目环境-vue-cli-3-0-2-0-使用-vue-init-webpack-项目名称" class="headerlink" title="搭建vue项目环境 vue-cli 3.0 2.0 使用 vue init webpack 项目名称"></a>搭建vue项目环境 vue-cli 3.0 2.0 使用 vue init webpack 项目名称</h4><h6 id="使用-vue-cli-创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装-vue-cli-yarn-global-add-vue-cli-版本号，然后创建项目："><a href="#使用-vue-cli-创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装-vue-cli-yarn-global-add-vue-cli-版本号，然后创建项目：" class="headerlink" title="使用 @vue-cli 创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装 vue-cli yarn global add @vue-cli@版本号，然后创建项目："></a>使用 @vue-cli 创建项目结构，首先要全局（也可以本地安装，全局安装可能会需要配置环境变量）安装 vue-cli yarn global add @vue-cli@版本号，然后创建项目：</h6><h6 id="vue-create-项目名称-然后进入项目目录-安装-serve-（相当于-react-中的dev-server-可以本地启动一个服务器展示我们的运行效果）安装命令-yarn-add-serve-启动项目-yarn-serve"><a href="#vue-create-项目名称-然后进入项目目录-安装-serve-（相当于-react-中的dev-server-可以本地启动一个服务器展示我们的运行效果）安装命令-yarn-add-serve-启动项目-yarn-serve" class="headerlink" title="vue create 项目名称 然后进入项目目录 安装 serve （相当于 react 中的dev-server,可以本地启动一个服务器展示我们的运行效果）安装命令 yarn add serve, 启动项目 yarn serve"></a>vue create 项目名称 然后进入项目目录 安装 serve （相当于 react 中的dev-server,可以本地启动一个服务器展示我们的运行效果）安装命令 yarn add serve, 启动项目 yarn serve</h6><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><h6 id="写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用"><a href="#写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用" class="headerlink" title="写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用"></a>写项目前务必先熟悉一下目录结构，明白每一个文件夹层级的作用</h6><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><h6 id="使用插件生成基本的vue组件的代码结构，vscode-编辑器插件名：vscode-snippets-Vetur"><a href="#使用插件生成基本的vue组件的代码结构，vscode-编辑器插件名：vscode-snippets-Vetur" class="headerlink" title="使用插件生成基本的vue组件的代码结构，vscode 编辑器插件名：vscode snippets,  Vetur"></a>使用插件生成基本的vue组件的代码结构，vscode 编辑器插件名：vscode snippets,  Vetur</h6><h6 id="webstorem-插件名：-vue-snippets"><a href="#webstorem-插件名：-vue-snippets" class="headerlink" title="webstorem 插件名： vue snippets"></a>webstorem 插件名： vue snippets</h6><h6 id="snippets-插件的作用就是快速创建不同类型文件的基本代码结构，例如，在-vue-文件中，使用vbase-命令会生成相应的-template-script-和-style-标签"><a href="#snippets-插件的作用就是快速创建不同类型文件的基本代码结构，例如，在-vue-文件中，使用vbase-命令会生成相应的-template-script-和-style-标签" class="headerlink" title="snippets 插件的作用就是快速创建不同类型文件的基本代码结构，例如，在.vue 文件中，使用vbase 命令会生成相应的 template script 和 style 标签"></a>snippets 插件的作用就是快速创建不同类型文件的基本代码结构，例如，在.vue 文件中，使用vbase 命令会生成相应的 template script 和 style 标签</h6><p><strong>我还是觉得能手写就手写吧，可能是之前写过的缘故，现在觉得好熟悉呀！</strong></p>
<h4 id="Vue-中的-以及-scss-中的-这个也好熟悉呀，之前项目有用过的"><a href="#Vue-中的-以及-scss-中的-这个也好熟悉呀，之前项目有用过的" class="headerlink" title="Vue 中的 @ 以及 scss 中的 ~  这个也好熟悉呀，之前项目有用过的"></a>Vue 中的 @ 以及 scss 中的 ~  这个也好熟悉呀，之前项目有用过的</h4><h6 id="vue-中-vue-js-文件的引用都可以使用-as-src-is-an-alias-to-src-而在scss-文件中呢想要使用-当做-src-需要在前面添加-例如："><a href="#vue-中-vue-js-文件的引用都可以使用-as-src-is-an-alias-to-src-而在scss-文件中呢想要使用-当做-src-需要在前面添加-例如：" class="headerlink" title="vue 中 .vue .js 文件的引用都可以使用 @ as src  @ is an alias to /src,而在scss 文件中呢想要使用 @ 当做 src 需要在前面添加 ~ 例如："></a>vue 中 .vue .js 文件的引用都可以使用 @ as src  @ is an alias to /src,而在scss 文件中呢想要使用 @ 当做 src 需要在前面添加 ~ 例如：</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">'~@/assets/index.scss'</span>  // 引入 src 下的 assets/index.scss</span><br></pre></td></tr></table></figure>
<h6 id="发现好多-vue-项目都使用-scss"><a href="#发现好多-vue-项目都使用-scss" class="headerlink" title="发现好多 vue 项目都使用 scss"></a>发现好多 vue 项目都使用 scss</h6><h6 id="对了，webstorm-中使用-可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下-webpack-目录为当前项目的node-modules-vue-cli-service-webpack-config-js"><a href="#对了，webstorm-中使用-可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下-webpack-目录为当前项目的node-modules-vue-cli-service-webpack-config-js" class="headerlink" title="对了，webstorm 中使用 ~@ 可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下 webpack 目录为当前项目的node_modules/@vue\cli-service\webpack.config.js"></a>对了，webstorm 中使用 ~@ 可能会报红线，但不影响使用，如果不想让它报红线，可以配置一下 webpack 目录为当前项目的node_modules/@vue\cli-service\webpack.config.js</h6><h4 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h4>
        
          <p class="article-more-link">
            <a href="/2020/06/24/vue-account/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/24/vue-account/" data-id="ckd2l3zix0018kcw1l1velqrh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue项目/">vue项目</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-打包发布问题记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/21/react-打包发布问题记录/" class="article-date">
  <time datetime="2020-06-21T08:44:09.000Z" itemprop="datePublished">2020-06-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/21/react-打包发布问题记录/">react 打包发布问题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><h6 id="今天把这几天学习的项目写完了，然后准备打包，发布到-Github-Pages-上，结果打包后发现各种报错，总的来说就是-打包后的-css-和-js-文件引入错误，路径不对，报错如下："><a href="#今天把这几天学习的项目写完了，然后准备打包，发布到-Github-Pages-上，结果打包后发现各种报错，总的来说就是-打包后的-css-和-js-文件引入错误，路径不对，报错如下：" class="headerlink" title="今天把这几天学习的项目写完了，然后准备打包，发布到 Github Pages 上，结果打包后发现各种报错，总的来说就是 打包后的 css 和 js 文件引入错误，路径不对，报错如下："></a>今天把这几天学习的项目写完了，然后准备打包，发布到 Github Pages 上，结果打包后发现各种报错，总的来说就是 打包后的 css 和 js 文件引入错误，路径不对，报错如下：</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Refused to apply style <span class="keyword">from</span> <span class="string">'http://localhost:3000/assets/styles/custom-style.css'</span> because its MIME type (<span class="string">'text/html'</span>) is not a supported stylesheet MIME type, and strict MIME checking is enabled.</span><br></pre></td></tr></table></figure>
<h6 id="百度了一下，有人说是要在-packge-json-中指定-homepage-为-因为打开控制台发现-index-html引入的资源文件是从-下开始找的，应该在-下开始查找"><a href="#百度了一下，有人说是要在-packge-json-中指定-homepage-为-因为打开控制台发现-index-html引入的资源文件是从-下开始找的，应该在-下开始查找" class="headerlink" title="百度了一下，有人说是要在 packge.json 中指定 homepage 为 .,因为打开控制台发现 index.html引入的资源文件是从 / 下开始找的，应该在 ./ 下开始查找"></a>百度了一下，有人说是要在 packge.json 中指定 homepage 为 .,因为打开控制台发现 index.html引入的资源文件是从 / 下开始找的，应该在 ./ 下开始查找</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"homepage"</span>:<span class="string">"."</span></span><br></pre></td></tr></table></figure>
<h6 id="百度看到一个对build命令后输出的提示的一个解释："><a href="#百度看到一个对build命令后输出的提示的一个解释：" class="headerlink" title="百度看到一个对build命令后输出的提示的一个解释："></a>百度看到一个对build命令后输出的提示的一个解释：</h6><p>你必须把build里的文件直接放到应用服务器的根路径下，比如，你的服务器IP是172.16.38.253，应用服务器端口为8080，你应该保证<a href="http://172.16.38.253:8080这种访问方式，访问到的是你的build下的文件。如果你希望以http://172.16.38.253:8080/build/index.htm这种方式访问应用，那么你可以在package.json文件中增加一个homepage字段，如下：" target="_blank" rel="noopener">http://172.16.38.253:8080这种访问方式，访问到的是你的build下的文件。如果你希望以http://172.16.38.253:8080/build/index.htm这种方式访问应用，那么你可以在package.json文件中增加一个homepage字段，如下：</a></p>
<p>“homepage”: “.”,</p>
<h6 id="不管怎样，这样添加后发现-index-html-中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲："><a href="#不管怎样，这样添加后发现-index-html-中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲：" class="headerlink" title="不管怎样，这样添加后发现 index.html 中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲："></a>不管怎样，这样添加后发现 index.html 中引用资源文件路径正确了，可是新的问题来了，当我切换路由时发现页面空白，控制台报错也是加载资源的问题，后来百度后发现有人讲：</h6><h6 id="BrowserRouter会变成类似这样的路径-http-111-230-139-105-3001-detail-9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据"><a href="#BrowserRouter会变成类似这样的路径-http-111-230-139-105-3001-detail-9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据" class="headerlink" title="BrowserRouter会变成类似这样的路径  http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据"></a>BrowserRouter会变成类似这样的路径  <a href="http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据" target="_blank" rel="noopener">http://111.230.139.105:3001/detail/9459469，这样的路径在访问服务器时，服务器会认为是请求查找某个接口数据</a></h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This request URL /detail/9459469 was not found on this server.</span><br></pre></td></tr></table></figure>
<p><strong>所以这个时候必须使用 HashRouter,这时候访问具体页面时就是<a href="http://111.230.139.105:3001/#/detail/9459469" target="_blank" rel="noopener">http://111.230.139.105:3001/#/detail/9459469</a>  改为 HashRouter 后发现问题解决了</strong></p>
<p>另外,webpack打包时要添加NODE_ENV,并且将devtool:’eval-source-map’,去除，不然build出来的js特别大，source map是为了代码出错后采用source-map的形式直接显示你出错代码的位置</p>
<p>打包生产包时去除，加上这两个后大部分简单单页面应用会在100k到200k</p>
<h4 id="HashRouter-和-BrowserRouter-区别"><a href="#HashRouter-和-BrowserRouter-区别" class="headerlink" title="HashRouter 和 BrowserRouter 区别"></a>HashRouter 和 BrowserRouter 区别</h4><p>一、从原理上</p>
<p>HashRouter在路径中包含了#，相当于HTML的锚点定位。（<code>#</code> 符号的英文叫hash，所以叫HashRouter，和散列没关系哦））</p>
<p>而BrowserRouter使用的是HTML5的新特性History，没有HashRouter(锚点定位)那样通用，低版本浏览器可能不支持。</p>
<p>二、从用法上</p>
<p>BrowserRouter进行组件跳转时可以传递任意参数实现组件间的通信，而HashRouter不能(除非手动拼接URL字符串)，因此一般配合Redux使用，实现组件间的数据通信。</p>
<p>三、生产实践</p>
<p>1.HashRouter</p>
<p> HashRouter相当于锚点定位，因此不论#后面的路径怎么变化，请求的都相当于是#之前的那个页面。可以很容易的进行前后端不分离的部署(也就是把前端打包后的文件放到服务器端的public或static里)，</p>
<p>因为请求的链接都是ip地址:端口/#/xxxx，因此请求的资源路径永远为/，相当于index.html，而其他的后端API接口都可以正常请求，不会和/冲突，由于前后端不分离也不会产生跨域问题。</p>
<p>缺点就是丑，路径里总有个#，宝宝表示强迫症犯了…</p>
<p>2.BrowserRouter</p>
<p>因为BrowserRouter模式下请求的链接都是ip地址:端口/xxxx/xxxx，因此相当于每个URL都会访问一个不同的后端地址，如果后端没有覆盖到路由就会产生404错误。</p>
<p>可以通过加入中间件解决，放在服务器端路由匹配的最后，如果前面的API接口都不匹配，则返回index.html页面。但这样也有一些小问题，因为要求前端路由和后端路由的URL不能重复。</p>
<p>比如商品列表组件叫/product/list，而请求商品列表的API也是/product/list，那么就会访问不到页面，而是被API接口匹配到。</p>
<p>解决方法:</p>
<p>进行前后端分离的部署，比如前端地址ip1:端口1，后端接口地址ip2:端口2，使用Nginx反向代理服务器进行请求分发。前端向后端发起请求的URL为nginx所在的服务器+/api/xxx，通过NGINX的配置文件判断，如果URL以api开头则转发至后端接口，否则转发至前端的地址，访问项目只需访问Nginx服务器即可。</p>
<p>参考：<a href="https://www.cnblogs.com/flamestudio/p/11965991.html" target="_blank" rel="noopener">https://www.cnblogs.com/flamestudio/p/11965991.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/21/react-打包发布问题记录/" data-id="ckd2l3zis0014kcw1ts63os6g" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/打包/">打包</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-js-装饰器" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/js-装饰器/" class="article-date">
  <time datetime="2020-06-13T05:18:15.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/js-装饰器/">js 装饰器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong><code>Decorator</code> 是 ES7 的一个新语法正如其“装饰器”的叫法所表达的，他通过添加<code>@方法名</code>可以对一些对象进行装饰包装然后返回一个被包装过的对象，可以装饰的对象包括：类，属性，方法等。</strong> 在使用它之前需要引入babel模块 <code>transform-decorators-legacy</code> 编译成 ES5 或 ES6</p>
<h3 id="1-类的装饰"><a href="#1-类的装饰" class="headerlink" title="1. 类的装饰"></a>1. 类的装饰</h3><p>当装饰的对象是类时，我们操作的就是这个类本身，即装饰器函数的第一个参数，就是所要装饰的目标类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line">class A &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 等同于</span><br><span class="line">class A &#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure>
<h3 id="2-属性或方法的装饰"><a href="#2-属性或方法的装饰" class="headerlink" title="2. 属性或方法的装饰"></a>2. 属性或方法的装饰</h3><p><strong>对于类属性或方法的装饰本质是操作其描述符，可以把此时的装饰器理解成是 <code>Object.defineProperty(obj, prop, descriptor)</code>的语法糖。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  @readonly(<span class="literal">false</span>)</span><br><span class="line">  method() &#123; <span class="built_in">console</span>.log(<span class="string">'cat'</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target, key, descriptor</span>) </span>&#123; </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 此处 target 为 C.prototype; </span></span><br><span class="line"><span class="comment">	* key 为 method;</span></span><br><span class="line"><span class="comment">    * 原 descriptor 为：&#123; value: f, enumarable: false, writable: true, configurable: true &#125;</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    descriptor.writable = value</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> C()</span><br><span class="line">c.method = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'dog'</span>)</span><br><span class="line"></span><br><span class="line">c.method() <span class="comment">// cat</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> oldValue = descriptor.initializer &amp;&amp; descriptor.initializer.call(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"-----"</span> + oldValue); </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"读取值..."</span>);</span><br><span class="line">      <span class="keyword">return</span> oldValue + <span class="string">"!"</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"现在在设置值..."</span>);</span><br><span class="line">      oldValue = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  @observable</span><br><span class="line">  title = <span class="string">"饥⼈⾕"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> App();</span><br><span class="line"><span class="built_in">console</span>.log(app.title);</span><br><span class="line">app.title = <span class="string">"jirengu.com"</span>;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/js-装饰器/" data-id="ckd2l3zid000skcw12na2apxh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js/">js</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-嘚啵嘚两句-class-和-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/嘚啵嘚两句-class-和-function/" class="article-date">
  <time datetime="2020-06-13T05:10:42.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/嘚啵嘚两句-class-和-function/">嘚啵嘚两句 class 和 function</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="class"><a href="#class" class="headerlink" title="class"></a>class</h4><h6 id="学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"><a href="#学了这么久的js了，今天突然看到class-不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。" class="headerlink" title="学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。"></a>学了这么久的js了，今天突然看到class 不认识了。对它的来源毫无头绪。看来是忘光了，于是花了两分钟回想了一下。</h6><h6 id="js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用"><a href="#js中我们可以通过-function-关键字定义一个函数来执行，浏览器也认识这个关键字，class-关键字是-es6的语法，浏览器也认识，class-的本质是一个-function-函数，但它并不能像传统的函数那样直接来用，因为正如它的名字-class-它是作为一个-类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new-这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想-function-函数名，我们直接-函数名（）-即可调用" class="headerlink" title="js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用"></a>js中我们可以通过 function 关键字定义一个函数来执行，浏览器也认识这个关键字，class 关键字是 es6的语法，浏览器也认识，class 的本质是一个 function 函数，但它并不能像传统的函数那样直接来用，因为正如它的名字 class 它是作为一个 类对象来用的。所以使用它可以在内部定义方法，定义属性。调用时，new 这个类对象，获取到它的实例，然后调用该对象身上定义的相关属性，方法即可。并不想 function 函数名，我们直接 函数名（） 即可调用</h6><p>今天又犯迷瞪了，还是基本功不扎实</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/嘚啵嘚两句-class-和-function/" data-id="ckd2l3zj9001gkcw1pxs0zjix" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/js基本功/">js基本功</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-mobx" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/13/mobx/" class="article-date">
  <time datetime="2020-06-13T04:05:32.000Z" itemprop="datePublished">2020-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/13/mobx/">mobx</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="全局状态管理"><a href="#全局状态管理" class="headerlink" title="全局状态管理"></a>全局状态管理</h4><h6 id="之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理"><a href="#之前在-class-组件中通过-state-来实现状态管理，存储数据，在-function-组件中我们通过-useState-来实现状态管理" class="headerlink" title="之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理"></a>之前在 class 组件中通过 state 来实现状态管理，存储数据，在 function 组件中我们通过 useState 来实现状态管理</h6><h6 id="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"><a href="#上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。" class="headerlink" title="上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。"></a>上面这些都是父子关系之间组件传值可以通过共享state中的数据。如果层级嵌套十分严重，那么共享数据会变得十分复杂。</h6><h6 id="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux"><a href="#假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react-中可以用-redux-mobx-Vue-中有-vux" class="headerlink" title="假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux."></a>假如我们可以把一些组件会公用的一些数据放在组件外面，那个组件需要就直接拿即可，就十分方便了，而且当我们修改了这些公用的全局的数据，对应的引用这个数据的组件也会自动更新。所以我们需要这个全局状态管理工具，react 中可以用 redux,mobx Vue 中有 vux.</h6><h4 id="mobx"><a href="#mobx" class="headerlink" title="mobx"></a>mobx</h4><p><strong>state</strong></p>
<h6 id="state-中保存了我们要维护的一些数据，也就是一个数据容器"><a href="#state-中保存了我们要维护的一些数据，也就是一个数据容器" class="headerlink" title="state 中保存了我们要维护的一些数据，也就是一个数据容器"></a>state 中保存了我们要维护的一些数据，也就是一个数据容器</h6><p><strong>Action</strong></p>
<h6 id="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"><a href="#如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx-提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）" class="headerlink" title="如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）"></a>如果我们想要修改这个state中管理的数据，不建议直接修改它，要使用mobx 提供的一个action方法去修改，保证了数据的安全，也可以追溯用户的操作（打印日志等）</h6><p><strong>computed value</strong> 计算属性值</p>
<h6 id="当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。"><a href="#当state中维护的数据发生改变时，就会引起-计算属性值得改变，也就是说这个-computed-value-是根据这个-state-中数据的值来生成的。" class="headerlink" title="当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。"></a>当state中维护的数据发生改变时，就会引起 计算属性值得改变，也就是说这个 computed value 是根据这个 state 中数据的值来生成的。</h6><p><strong>Reaction</strong>s  反应</p>
<h6 id="当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions"><a href="#当state-中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是-reactions" class="headerlink" title="当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions"></a>当state 中数据发生改变时，如果此时用户需要在这个时候做一些事情，这些事情就是 reactions</h6><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;observable,computed,action,autorun&#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="comment">// todos 就是要监控的数据 通过 observale 函数来生成，相当于state中的数据</span></span><br><span class="line"><span class="keyword">const</span> todos = (observable([</span><br><span class="line">    &#123;</span><br><span class="line">        title:<span class="string">'起床'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'穿衣'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        title:<span class="string">'洗漱'</span>,</span><br><span class="line">        completed:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">]))</span><br><span class="line"></span><br><span class="line"><span class="comment">//Computed values 这个值是通过 state 中数据得来的，当state 数据更新时，它也会更新</span></span><br><span class="line"><span class="comment">// 通过 computed()函数，操作 state 中的数据</span></span><br><span class="line"><span class="keyword">let</span> uncompletedCount = computed(<span class="function"><span class="params">()</span>=&gt;</span> todos.filter(<span class="function"><span class="params">todo</span>=&gt;</span> !todo.completed.length);</span><br><span class="line"><span class="comment">//Reactions  当state 和 computedValue 改变时会触发 reactions</span></span><br><span class="line">  autorun = <span class="function">(<span class="params">(</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`剩余任务：<span class="subst">$&#123;uncompletedCount&#125;</span>`</span></span><br><span class="line">        todos</span><br><span class="line">         .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line">         .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line">         .join(<span class="string">", "</span>)</span><br><span class="line">    ),</span><br><span class="line">&#125;)       </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">``</span>,.....)  <span class="comment">// console.log 可以这样写的</span></span><br><span class="line"><span class="comment">//这个方法就是 当state 和 computedvalue 变化时，会自动运行这个 autrun 函数，打印出state 中未完成的任务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Actions  用来改变被观察者 也就是 state 中的数据</span></span><br><span class="line"><span class="keyword">const</span> doTask = action(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    todos.find(<span class="function"><span class="params">todo</span>=&gt;</span>!todo.completed).completed = <span class="literal">true</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// arry.find(item=&gt;) 函数 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。  一次只返回一个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// doTask 这个函数，因为action 本身是个函数赋值给 doTask 所以它也是个函数,只不过在action 参数中的函数中做了一些处理，来修改 state 也就是 todos 中的数据。</span></span><br></pre></td></tr></table></figure>
<h4 id="mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记"><a href="#mobx-装饰器写法-装饰器-是-ES2016-也就是-es7-的新语法-详情看-装饰器笔记" class="headerlink" title="mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)"></a>mobx 装饰器写法 (装饰器 是 ES2016 也就是 es7 的新语法,详情看 装饰器笔记)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; observable, autorun, computed, action &#125; <span class="keyword">from</span> <span class="string">'mobx'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Todo</span> </span>&#123;</span><br><span class="line"> @observable todos = []</span><br><span class="line"> <span class="keyword">constructor</span>() &#123;</span><br><span class="line"> autorun(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(</span><br><span class="line"> <span class="string">`剩余任务:<span class="subst">$&#123;<span class="keyword">this</span>.uncompletedCount&#125;</span>`</span>,</span><br><span class="line"> <span class="keyword">this</span>.todos</span><br><span class="line"> .filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed)</span><br><span class="line"> .map(<span class="function"><span class="params">todo</span> =&gt;</span> todo.title)</span><br><span class="line"> .join(<span class="string">", "</span>)</span><br><span class="line"> );</span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> @computed get uncompletedCount() &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).length;</span><br><span class="line"> &#125;</span><br><span class="line">@action addTodo(title) &#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.push(&#123;</span><br><span class="line"> title: title,</span><br><span class="line"> completed: <span class="literal">false</span></span><br><span class="line"> &#125;);</span><br><span class="line"> &#125;</span><br><span class="line"> @action doTask()&#123;</span><br><span class="line"> <span class="keyword">this</span>.todos.find(<span class="function"><span class="params">todo</span> =&gt;</span> !todo.completed).completed = <span class="literal">true</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> todo = <span class="built_in">window</span>.todo = <span class="keyword">new</span> Todo();</span><br><span class="line">todo.addTodo(<span class="string">'吃饭'</span>);</span><br><span class="line">todo.doTask()</span><br></pre></td></tr></table></figure>
<p><strong>核心思想：状态的改变引发⼀系列⾃动⾏为</strong></p>
<h4 id="react-项目中使用装饰器"><a href="#react-项目中使用装饰器" class="headerlink" title="react 项目中使用装饰器"></a>react 项目中使用装饰器</h4><p>操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create-react-app</span><br><span class="line"></span><br><span class="line">yarn eject 或者 npm run eject 暴露出配置文件</span><br><span class="line"></span><br><span class="line">yarn add @babel/plugin-proposal-decorators  //安装支持 装饰器的插件</span><br><span class="line">修改package.json， 找到 babel字段， 添加</span><br><span class="line">//查看 npm 上 plugin-proposal-decorators 包的用法</span><br><span class="line"> <span class="string">"babel"</span>: &#123;</span><br><span class="line"> <span class="string">"plugins"</span>: [</span><br><span class="line"> <span class="string">"@babel/plugin-proposal-decorators"</span></span><br><span class="line"> ],</span><br><span class="line"> <span class="string">"presets"</span>: [</span><br><span class="line"> <span class="string">"react-app"</span></span><br><span class="line"> ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="react-mobx"><a href="#react-mobx" class="headerlink" title="react-mobx"></a>react-mobx</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/13/mobx/" data-id="ckd2l3zik000xkcw1ir43g2vz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mobx/">mobx</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-router" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-router/" class="article-date">
  <time datetime="2020-06-12T06:53:47.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-router/">react-router</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>npm install –save react-router-dom</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h6 id="在页面上引入所需的组件对象"><a href="#在页面上引入所需的组件对象" class="headerlink" title="在页面上引入所需的组件对象"></a>在页面上引入所需的组件对象</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;BrowserRouter || HashRouter <span class="keyword">as</span> Router,</span><br><span class="line">       Switch,</span><br><span class="line">        Route,</span><br><span class="line">        Link</span><br><span class="line">       &#125;  <span class="comment">// 取别名</span></span><br><span class="line"><span class="comment">// hashRouter 和 BrowserRouter 区别是url 一个带 # 一个不带</span></span><br><span class="line"></span><br><span class="line">BrowserRouter 的作用就是声明这个组件被 router 接管了。</span><br><span class="line"><span class="comment">// 在组件 return 的 逻辑中，我们使用 &lt;Router&gt; 标签来包裹这些 路由标签，Switch,route,link 等</span></span><br><span class="line">Switch 相当于 js 中的 <span class="keyword">switch</span> 语句主要用来判断不同的条件执行不同的代码</span><br><span class="line">Route 标签则是用来渲染组件的，一般会包裹一个组件，或者在它的属性上使用 component，children 来指定要渲染的组件   </span><br><span class="line">Link 标签则是指定点击时要跳转的组件路径 很像 a 链接</span><br></pre></td></tr></table></figure>
<p><strong>下面是一个简单的使用</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;BrowserRouter <span class="keyword">as</span> Router,</span><br><span class="line">    Switch,</span><br><span class="line">    Route,</span><br><span class="line">    Link</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Nav</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Router&gt;</span><br><span class="line">            &lt;nav&gt;</span><br><span class="line">                &lt;Link to=<span class="string">"/home"</span>&gt;首页&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">                &lt;Link to="/</span>history<span class="string">"&gt;历史&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/my<span class="string">"&gt;我的&lt;/Link&gt;</span></span><br><span class="line"><span class="string">                &lt;Link to="</span>/about<span class="string">"&gt;关于&lt;/Link&gt;</span></span><br><span class="line"><span class="string">            &lt;/nav&gt;</span></span><br><span class="line"><span class="string">            &lt;Switch&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/about<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;About/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/history<span class="string">" component=&#123;History&#125;&gt;              </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/my<span class="string">" children=&#123;&lt;My/&gt;&#125;&gt;</span></span><br><span class="line"><span class="string">                   </span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">                &lt;Route path="</span>/home<span class="string">"&gt;</span></span><br><span class="line"><span class="string">                    &lt;Home/&gt;</span></span><br><span class="line"><span class="string">                &lt;/Route&gt;</span></span><br><span class="line"><span class="string">            &lt;/Switch&gt;</span></span><br><span class="line"><span class="string">        &lt;/Router&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">function Home()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;首页&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function History()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;历史&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function My()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;我的&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">function About()&#123;</span></span><br><span class="line"><span class="string">    return &lt;h2&gt;关于&lt;/h2&gt;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">export default Nav;</span></span><br></pre></td></tr></table></figure>
<h6 id="当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。"><a href="#当然一般情况下我们会把这个路由-Router-标签放在-index-js-中，包裹所有的-组件，这样在其他组件中我们无需再引入这个-router，直接使用其提供的标签即可。" class="headerlink" title="当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。"></a>当然一般情况下我们会把这个路由 Router 标签放在 index.js 中，包裹所有的 组件，这样在其他组件中我们无需再引入这个 router，直接使用其提供的标签即可。</h6><h4 id="Navlink-amp-Redirect"><a href="#Navlink-amp-Redirect" class="headerlink" title="Navlink &amp; Redirect"></a>Navlink &amp; Redirect</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Navlink,Redirect&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br></pre></td></tr></table></figure>
<h6 id="navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签"><a href="#navlink-为我们提供了一个-activeClassName-css-属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个-标签" class="headerlink" title="navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签"></a>navlink 为我们提供了一个 activeClassName css 属性，只有当这个link被选中时，它才会拥有这个属性，我们可以通过事先给它绑定样式来实现我们当前选中的是哪个 标签</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;NavLink activeClassName=<span class="string">'active'</span>exact  to=<span class="string">"/"</span>&gt;首页&lt;<span class="regexp">/NavLink&gt;</span></span><br><span class="line"><span class="regexp">&lt;NavLink activeClassName='active'exact  to="/</span>history<span class="string">"&gt;历史&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active' exact  to="</span>/my<span class="string">"&gt;我的&lt;/NavLink&gt;</span></span><br><span class="line"><span class="string">&lt;NavLink activeClassName='active'exact  to="</span>/about<span class="string">"&gt;关于&lt;/NavLink&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"><a href="#有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link-所以当首页的path是-时，其他页面分别是-xxx-，它只做了一级匹配，它只匹配一级url-也就是它值对比-一个-后面的-sxx-它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问-about-时，也匹配-首页，所以首页也会应用-css。为了解决这个问题，我们可以给它加一个属性-exact-就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧" class="headerlink" title="有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧"></a>有一个匹配的问题，因为它最终还是通过当前访问的url来确定你点击的是哪个link,所以当首页的path是 / 时，其他页面分别是 / xxx ，它只做了一级匹配，它只匹配一级url,也就是它值对比 一个 /,后面的/sxx 它都不管了，只要你有我访问路径的一层我就当做你被选中了。那么当页面访问 /about 时，也匹配/ 首页，所以首页也会应用 css。为了解决这个问题，我们可以给它加一个属性 exact 就会完全匹配，一般只给首页加，因为其他的url一般不会相同，看情况吧</h6><h4 id="Redirect-重定向到。。。。"><a href="#Redirect-重定向到。。。。" class="headerlink" title="Redirect 重定向到。。。。"></a>Redirect 重定向到。。。。</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Redirect to =<span class="string">'/about'</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">Redirect</span>&gt;</span></span> <span class="comment">//重定向到 /about 这个路径下的 组件里</span></span><br></pre></td></tr></table></figure>
<h4 id="React-router-代码分割"><a href="#React-router-代码分割" class="headerlink" title="React-router 代码分割"></a>React-router 代码分割</h4><h6 id="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"><a href="#其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来" class="headerlink" title="其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来"></a>其实就是把需要引入的代码在不同的时机（需要的时候）分别引入进来</h6><h6 id="使用之前学习的const-组件-React-lazy-gt-import-……"><a href="#使用之前学习的const-组件-React-lazy-gt-import-……" class="headerlink" title="使用之前学习的const 组件 = React.lazy(()=&gt; import ……)"></a>使用之前学习的const 组件 = React.lazy(()=&gt; import ……)</h6><h4 id="React-router-滚动设置"><a href="#React-router-滚动设置" class="headerlink" title="React-router 滚动设置"></a>React-router 滚动设置</h4><h6 id="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop"><a href="#单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在-a页面之前滚动的位置，切换到-b-时，也会默认在b页面-a-的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件-ScrollToTop" class="headerlink" title="单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop"></a>单页面应用，当我们切换不同的路由时，也就是不同的组件，我们在 a页面之前滚动的位置，切换到 b 时，也会默认在b页面 a 的位置，按理来说，切换后应该默认在当前组件页面的顶部才对，为了解决这个问题，我们定义一个组件 ScrollToTop</h6><p>引入 useLoacation</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;useLocation&#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="comment">//在组件中就可以使用 useLoaction 的方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;pathName&#125; = useLoaction();  <span class="comment">//获取到当前页面上的url 访问路径</span></span><br><span class="line">相当于浏览器中的 location 对象的 pathname 属性 location.pathname</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">ScrollToTop</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;pathName&#125; = useLoaction();</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[pathname])</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 我们使用 useEffect 监控 访问的url pathname ,当它发生改变的时候，将滚动到页面顶部</span></span><br><span class="line">这个组件放在全局任意一个地方即可</span><br><span class="line"></span><br><span class="line">也可以放在一个单独的组件中，放在单独组件中我们就不用监控这个 访问路径了，就让它一切换到这个组件的路径就将页面滚动到顶部即可</span><br><span class="line"><span class="keyword">export</span> funtion SrcollToTop()&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.scrollTo(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    &#125;,[])<span class="comment">//传递空 什么都不监控，那么就会只执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="useParams"><a href="#useParams" class="headerlink" title="useParams"></a>useParams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取url中传递来的 参数</span></span><br><span class="line">例如页面访问 /blog/aaaa</span><br><span class="line">&lt;Route path = <span class="string">'/blog/:slug'</span>&gt;</span><br><span class="line">    <span class="comment">//这个路由渲染的组件是 blog</span></span><br><span class="line">    &lt;BlogPost/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">当访问/</span>blog/aaa 会到这个路由，进而访问到这个 blogPost 组件</span><br><span class="line">那么在 blogPost中</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlogPost</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;slug&#125; = useParams();  <span class="comment">// slug 就能得到url传递来的参数</span></span><br><span class="line">    <span class="keyword">return</span> ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>更多用例查看 react-router 官网</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-router/" data-id="ckd2l3ziu0015kcw145usa6t0" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/react/">react</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-react-css使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/12/react-css使用/" class="article-date">
  <time datetime="2020-06-12T06:21:04.000Z" itemprop="datePublished">2020-06-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/12/react-css使用/">react-css使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="样式引入"><a href="#样式引入" class="headerlink" title="样式引入"></a>样式引入</h4><h6 id="现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件"><a href="#现在我们都通过-create-react-app-来创建-react-项目，在-create-react-app-中支持我们使用-module-的方式来引入-css-文件" class="headerlink" title="现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件"></a>现在我们都通过 create-react-app 来创建 react 项目，在 create react app 中支持我们使用 module 的方式来引入 css 文件</h6><p>es6 中我们引入文件可以使用 import 关键字即可，坏处是这个css 会全局公用</p>
<p>第二种方式 引入 css modules 这种方式可以指定使用的是哪个 css 文件的样式，但该 css 文件的命名必须为 XXX.module.css </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Error.module.css'</span>;</span><br><span class="line"><span class="comment">//使用时可以直接 styles.文件中的样式选择器即可使用</span></span><br><span class="line"><span class="comment">//例如 css 中有一个 .error &#123;color:red&#125;</span></span><br><span class="line">style.error 即可</span><br><span class="line"><span class="comment">// 这样这个 css 就只在这个组件中生效</span></span><br></pre></td></tr></table></figure>
<hr>
<p><strong>style-components</strong></p>
<h6 id="之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装"><a href="#之前我们引入-css-都是需要引入-css-文件，如果我们想要直接在-js-中写-css-需要使用-style-components-这个包-使用前需要先安装" class="headerlink" title="之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装"></a>之前我们引入 css 都是需要引入 css 文件，如果我们想要直接在 js 中写 css 需要使用 style-components 这个包 使用前需要先安装</h6><p>然后再组件中引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> style <span class="keyword">from</span> <span class="string">'style-components'</span></span><br><span class="line"><span class="comment">//然后再组件中定义这个样式</span></span><br><span class="line"><span class="keyword">const</span> Wrapper = style.footer<span class="string">`border:1px solid red`</span>; 注意这个符号</span><br><span class="line"><span class="comment">//然后 直接使用这个 Wrapper 对象即可，此时这个包帮我们生成一个footer 标签，而且应用了我们定义的css。</span></span><br><span class="line">&lt;Wrapper&gt;someThing&lt;<span class="regexp">/Wrapper&gt;</span></span><br><span class="line"><span class="regexp">反正就记住这样用就好了，定义一个对象，然后想使用什么标签就 style.标签名`css 代码`,最后直接使用这个返回的对象即可，自动应用我们``中定义的样式</span></span><br><span class="line"><span class="regexp">===================================</span></span><br><span class="line"><span class="regexp">解密：</span></span><br><span class="line"><span class="regexp">style.footer`` 其实是一个函数 ``中的内容时参数，省略了小括号</span></span><br><span class="line"><span class="regexp">let style = &#123;footer:str=&gt;console.log(str)&#125;</span></span><br><span class="line"><span class="regexp">style.footer`border:1px solid blue`</span></span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/06/12/react-css使用/" data-id="ckd2l3ziq0012kcw1w9akazv9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/create-react-app/">create-react-app</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajax/">ajax</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/bom/">bom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/create-react-app/">create-react-app</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/css/">css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/dom/">dom</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/flex/">flex</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css/">html-css</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/https基础/">https基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js基本功/">js基本功</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js性能/">js性能</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mobx/">mobx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mock/">mock</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/product/">product</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/promise/">promise</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/summary/">summary</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue项目/">vue项目</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/webpack/">webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/对象/">对象</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/工程化/">工程化</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/打包/">打包</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/正则表达式/">正则表达式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/网站建站案例练习/">网站建站案例练习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/递归/">递归</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 10px;">JS</a> <a href="/tags/ajax/" style="font-size: 10px;">ajax</a> <a href="/tags/bom/" style="font-size: 10px;">bom</a> <a href="/tags/create-react-app/" style="font-size: 10px;">create-react-app</a> <a href="/tags/css/" style="font-size: 20px;">css</a> <a href="/tags/dom/" style="font-size: 10px;">dom</a> <a href="/tags/flex/" style="font-size: 10px;">flex</a> <a href="/tags/html-css/" style="font-size: 10px;">html-css</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/https基础/" style="font-size: 10px;">https基础</a> <a href="/tags/js/" style="font-size: 20px;">js</a> <a href="/tags/js基本功/" style="font-size: 10px;">js基本功</a> <a href="/tags/js性能/" style="font-size: 10px;">js性能</a> <a href="/tags/mobx/" style="font-size: 10px;">mobx</a> <a href="/tags/mock/" style="font-size: 10px;">mock</a> <a href="/tags/node-js/" style="font-size: 10px;">node.js</a> <a href="/tags/product/" style="font-size: 10px;">product</a> <a href="/tags/promise/" style="font-size: 10px;">promise</a> <a href="/tags/react/" style="font-size: 20px;">react</a> <a href="/tags/summary/" style="font-size: 10px;">summary</a> <a href="/tags/vue项目/" style="font-size: 10px;">vue项目</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/对象/" style="font-size: 10px;">对象</a> <a href="/tags/工程化/" style="font-size: 10px;">工程化</a> <a href="/tags/打包/" style="font-size: 10px;">打包</a> <a href="/tags/正则表达式/" style="font-size: 10px;">正则表达式</a> <a href="/tags/网站建站案例练习/" style="font-size: 10px;">网站建站案例练习</a> <a href="/tags/递归/" style="font-size: 10px;">递归</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/26/用户体验以及产品相关/">用户体验以及产品相关</a>
          </li>
        
          <li>
            <a href="/2020/07/21/防抖与节流/">防抖与节流</a>
          </li>
        
          <li>
            <a href="/2020/07/14/html-css-复习/">html-css 复习</a>
          </li>
        
          <li>
            <a href="/2020/06/24/vue-account/">vue-account</a>
          </li>
        
          <li>
            <a href="/2020/06/21/react-打包发布问题记录/">react 打包发布问题记录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 sheila<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>